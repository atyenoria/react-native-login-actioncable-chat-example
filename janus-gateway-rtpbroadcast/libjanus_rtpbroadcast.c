/*! \file   cm_rtpbcast.c
 * \author Lorenzo Miniero <lorenzo@meetecho.com>
 * \copyright GNU General Public License v3
 * \brief  Janus Streaming plugin
 * \details  This is a streaming plugin for Janus, allowing WebRTC peers
 * to watch/listen to pre-recorded files or media generated by another tool.
 * Specifically, the plugin currently supports three different type of streams:
 *
 * -# on-demand streaming of pre-recorded media files (different
 * streaming context for each peer);
 * -# live streaming of pre-recorded media files (shared streaming
 * context for all peers attached to the stream);
 * -# live streaming of media generated by another tool (shared
 * streaming context for all peers attached to the stream).
 *
 * For what concerns types 1. and 2., considering the proof of concept
 * nature of the implementation the only pre-recorded media files
 * that the plugins supports right now are raw mu-Law and a-Law files:
 * support is of course planned for other additional widespread formats
 * as well.
 *
 * For what concerns type 3., instead, the plugin is configured
 * to listen on a couple of ports for RTP: this means that the plugin
 * is implemented to receive RTP on those ports and relay them to all
 * peers attached to that stream. Any tool that can generate audio/video
 * RTP streams and specify a destination is good for the purpose: the
 * examples section contains samples that make use of GStreamer (http://gstreamer.freedesktop.org/)
 * but other tools like FFmpeg (http://www.ffmpeg.org/), LibAV (http://libav.org/)
 * or others are fine as well. This makes it really easy to capture and
 * encode whatever you want using your favourite tool, and then have it
 * transparently broadcasted via WebRTC using Janus.
 *
 * Streams to make available are listed in the plugin configuration file.
 * A pre-filled configuration file is provided in \c conf/janus.plugin.streaming.cfg
 * and includes a stream of every type.
 *
 * To add more streams or modify the existing ones, you can use the following
 * syntax:
 *
 * \verbatim
[stream-name]
type = rtp|live|ondemand|rtsp
       rtp = stream originated by an external tool (e.g., gstreamer or
             ffmpeg) and sent to the plugin via RTP
       live = local file streamed live to multiple listeners
              (multiple listeners = same streaming context)
       ondemand = local file streamed on-demand to a single listener
                  (multiple listeners = different streaming contexts)
       rtsp = stream originated by an external RTSP feed (only
              available if libcurl support was compiled)
id = <unique numeric ID>
description = This is my awesome stream
is_private = yes|no (private streams don't appear when you do a 'list' request)
filename = path to the local file to stream (only for live/ondemand)
secret = <optional password needed for manipulating (e.g., destroying
		or enabling/disabling) the stream>
pin = <optional password needed for watching the stream>
audio = yes|no (do/don't stream audio)
video = yes|no (do/don't stream video)
   The following options are only valid for the 'rtp' type:
audioport = local port for receiving audio frames
audiomcast = multicast group port for receiving audio frames, if any
audiopt = <audio RTP payload type> (e.g., 111)
audiortpmap = RTP map of the audio codec (e.g., opus/48000/2)
audiofmtp = Codec specific parameters, if any
videoport = local port for receiving video frames (only for rtp)
videomcast = multicast group port for receiving video frames, if any
videopt = <video RTP payload type> (e.g., 100)
videortpmap = RTP map of the video codec (e.g., VP8/90000)
videofmtp = Codec specific parameters, if any
   The following options are only valid for the 'rstp' type:
url = RTSP stream URL (only if type=rtsp)
\endverbatim
 *
 * \section streamapi Streaming API
 *
 * The Streaming API supports several requests, some of which are
 * synchronous and some asynchronous. There are some situations, though,
 * (invalid JSON, invalid request) which will always result in a
 * synchronous error response even for asynchronous requests.
 *
 * \c list , \c create , \c destroy , \c recording , \c enable and
 * \c disable are synchronous requests, which means you'll
 * get a response directly within the context of the transaction. \c list
 * lists all the available streams; \c create allows you to create a new
 * mountpoint dynamically, as an alternative to using the configuration
 * file; \c destroy removes a mountpoint and destroys it; \c recording
 * instructs the plugin on whether or not a live RTP stream should be
 * recorded while it's broadcasted; \c enable and \c disable respectively
 * enable and disable a mountpoint, that is decide whether or not a
 * mountpoint should be available to users without destroying it.
 *
 * The \c watch , \c start , \c pause , \c switch and \c stop requests
 * instead are all asynchronous, which means you'll get a notification
 * about their success or failure in an event. \c watch asks the plugin
 * to prepare the playout of one of the available streams; \c start
 * starts the actual playout; \c pause allows you to pause a playout
 * without tearing down the PeerConnection; \c switch allows you to
 * switch to a different mountpoint of the same kind (note: only live
 * RTP mountpoints supported as of now) without having to stop and watch
 * the new one; \c stop stops the playout and tears the PeerConnection
 * down.
 *
 * Actual API docs: TBD.
 *
 * \ingroup plugins
 * \ref plugins
 */

#include "janus/plugin.h"

#include <jansson.h>
#include <errno.h>
/* TODO @landswellsong those are not really portable, are they? */
#include <sys/poll.h>
#include <sys/time.h>
#include <netdb.h>
#include <netinet/ip.h>
#include <netinet/udp.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>

#include "janus/debug.h"
#include "janus/apierror.h"
#include "janus/config.h"
#include "janus/mutex.h"
#include "janus/rtp.h"
#include "janus/rtcp.h"
#include "janus/record.h"
#include "janus/utils.h"


/* Plugin information */
#define CM_RTPBCAST_VERSION			5
#define CM_RTPBCAST_VERSION_STRING	"0.0.5"
#define CM_RTPBCAST_DESCRIPTION		"This is a streaming plugin for Janus, allowing WebRTC peers to watch/listen to pre-recorded files or media generated by gstreamer."
#define CM_RTPBCAST_NAME			"JANUS CM video plugin"
#define CM_RTPBCAST_AUTHOR			"Meetecho s.r.l."
#define CM_RTPBCAST_PACKAGE			"janus.plugin.cm.rtpbroadcast"

/* Plugin methods */
janus_plugin *create(void);
int cm_rtpbcast_init(janus_callbacks *callback, const char *config_path);
void cm_rtpbcast_destroy(void);
int cm_rtpbcast_get_api_compatibility(void);
int cm_rtpbcast_get_version(void);
const char *cm_rtpbcast_get_version_string(void);
const char *cm_rtpbcast_get_description(void);
const char *cm_rtpbcast_get_name(void);
const char *cm_rtpbcast_get_author(void);
const char *cm_rtpbcast_get_package(void);
void cm_rtpbcast_create_session(janus_plugin_session *handle, int *error);
struct janus_plugin_result *cm_rtpbcast_handle_message(janus_plugin_session *handle, char *transaction, char *message, char *sdp_type, char *sdp);
void cm_rtpbcast_setup_media(janus_plugin_session *handle);
void cm_rtpbcast_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len);
void cm_rtpbcast_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len);
void cm_rtpbcast_hangup_media(janus_plugin_session *handle);
void cm_rtpbcast_destroy_session(janus_plugin_session *handle, int *error);
char *cm_rtpbcast_query_session(janus_plugin_session *handle);

/* Plugin setup */
static janus_plugin cm_rtpbcast_plugin =
	JANUS_PLUGIN_INIT (
		.init = cm_rtpbcast_init,
		.destroy = cm_rtpbcast_destroy,

		.get_api_compatibility = cm_rtpbcast_get_api_compatibility,
		.get_version = cm_rtpbcast_get_version,
		.get_version_string = cm_rtpbcast_get_version_string,
		.get_description = cm_rtpbcast_get_description,
		.get_name = cm_rtpbcast_get_name,
		.get_author = cm_rtpbcast_get_author,
		.get_package = cm_rtpbcast_get_package,

		.create_session = cm_rtpbcast_create_session,
		.handle_message = cm_rtpbcast_handle_message,
		.setup_media = cm_rtpbcast_setup_media,
		.incoming_rtp = cm_rtpbcast_incoming_rtp,
		.incoming_rtcp = cm_rtpbcast_incoming_rtcp,
		.hangup_media = cm_rtpbcast_hangup_media,
		.destroy_session = cm_rtpbcast_destroy_session,
		.query_session = cm_rtpbcast_query_session,
	);

/* Plugin creator */
janus_plugin *create(void) {
	JANUS_LOG(LOG_VERB, "%s created!\n", CM_RTPBCAST_NAME);
	return &cm_rtpbcast_plugin;
}


/* Useful stuff */
static volatile gint initialized = 0, stopping = 0;
static janus_callbacks *gateway = NULL;
static GThread *handler_thread;
static GThread *watchdog;
static GThread *udp_relay;
static void *cm_rtpbcast_handler(void *data);
static void cm_rtpbcast_relay_rtp_packet(gpointer data, gpointer user_data);
static void *cm_rtpbcast_relay_thread(void *data);
static char *str_replace(char *instr, const char *needle, const char *replace);

/* Helper to remove insane code duplication everywhere
 	 Sample illustrating use:
			something things[] = { X, Y, Z };
			_foreach(i, things) {
				print(things[i]);
			}

			Note, iterator variable exported in the current scope;
			*/
#define _foreach(var, container) size_t var; for (var = 0; var < sizeof(container)/sizeof(container[0]); var++)

/* To remove unnecessary duplication all over, all things are arrays of 2 now
 	 i.e. instead of audio_port you have port[AUDIO]
	 As a bonus, av_names[AUDIO] is "audio" string and so on
*/
#define AUDIO 0
#define VIDEO 1
#define AV		2
const char *av_names[] = { "audio", "video" };

static struct {
	const char *hostname;
	guint minport, maxport;
	const char *job_path;
	const char *job_pattern;
	const char *archive_path;
	const char *recording_pattern;
	const char *thumbnailing_pattern;
	guint thumbnailing_interval;
	guint thumbnailing_duration;
	guint mountpoint_info_interval;
	guint keyframe_distance_alert;
	guint udp_relay_interval;
	gboolean recording_enabled;
	gboolean simulate_bad_connection;
 	guint packet_loss_rate;
	gboolean udp_relay_queue_enabled;
	gboolean autoswitch;
} cm_rtpbcast_settings;

typedef struct cm_rtpbcast_codecs {
	gint pt[AV];
	char *rtpmap[AV];
	char *fmtp[AV];
} cm_rtpbcast_codecs;

#define STAT_SECOND 1000000
typedef struct cm_rtpbcast_stats {
	gdouble cur;

	/* FIXME do we need minmax here? */
	gdouble packet_loss_rate;
	guint64 packet_loss_count;

	guint64 start_usec;
	guint64 last_avg_usec;
	guint64 bytes_since_start;
	guint64 bytes_since_last_avg;

	guint32 start_seq;
	guint32 last_avg_seq;
	guint32 max_seq_since_last_avg;
	guint64 packets_since_start;
	guint64 packets_since_last_avg;

	janus_mutex stat_mutex;
} cm_rtpbcast_stats;
static void cm_rtpbcast_stats_restart(cm_rtpbcast_stats *);
static void cm_rtpbcast_stats_update(cm_rtpbcast_stats *, gsize, guint32, int);

typedef struct cm_rtpbcast_rtp_source cm_rtpbcast_rtp_source;
typedef struct cm_rtpbcast_recorder {
	janus_recorder *r;
	cm_rtpbcast_rtp_source *source;
	gboolean had_keyframe; /* if any keyframe has been passed to the recorder */
} cm_rtpbcast_recorder;

/* Forward declaration for pointer */
typedef struct cm_rtpbcast_session cm_rtpbcast_session;
typedef struct cm_rtpbcast_mountpoint {
	char *id;
	char *uid;
	char *name;
	char *description;

	gboolean enabled;

	gboolean recorded; 			/* Only sources[0] is recorded by default */
	cm_rtpbcast_recorder *rc[AV];	/* The Janus recorder instance for this mountpoint's audio/video, if enabled */
	cm_rtpbcast_recorder *trc[1];	/* Thumbnailing recorder, array for generic code sake */
	guint64 last_thumbnail; /* Positon (frames/time) of last thumbnail taken */
	gboolean whitelisted;
	struct in_addr allowed_ip;

	GArray *sources; // of type cm_rtpbcast_rtp_source*
	gint64 destroyed;

	cm_rtpbcast_session *session;
} cm_rtpbcast_mountpoint;
GHashTable *mountpoints;
static GList *old_mountpoints;
janus_mutex mountpoints_mutex;
/* TODO @landswellsong per-source recording */
static void cm_rtpbcast_start_recording(cm_rtpbcast_mountpoint *, int);
static void cm_rtpbcast_stop_recording(cm_rtpbcast_mountpoint *, int);
static void cm_rtpbcast_start_thumbnailing(cm_rtpbcast_mountpoint *, int);
static void cm_rtpbcast_stop_thumbnailing(cm_rtpbcast_mountpoint *, int);

typedef struct cm_rtpbcast_rtp_source {
	gboolean active;
	guint port[AV];
	in_addr_t mcast[AV];
	int fd[AV];
	cm_rtpbcast_codecs codecs;
	cm_rtpbcast_stats stats[AV];
	cm_rtpbcast_mountpoint *mp;

	int index;

	int frame_width;
	int frame_height;
	int frame_x_scale;
	int frame_y_scale;
	int frame_mbw;
	int frame_mbh;

	guint32 frame_count;
	guint32 frame_last_count;
	guint64 frame_last_usec;
	guint32 frame_rate;
	guint32 frame_key_last;
	guint32 frame_key_distance;

	gboolean frame_key_overdue;

	GList/*<unowned cm_rtpbcast_session>*/ *listeners;
	GList/*<unowned cm_rtpbcast_session>*/ *waiters;	 /* listeners waiting for keyframe */
	janus_mutex mutex;
} cm_rtpbcast_rtp_source;
static cm_rtpbcast_rtp_source* cm_rtpbcast_pick_source(GArray/* cm_rtpbcast_rtp_source* */ *, guint64);
static void cm_rtpbcast_schedule_switch(cm_rtpbcast_session *sessid, cm_rtpbcast_rtp_source *newsrc);
static void cm_rtpbcast_unschedule_switch(cm_rtpbcast_session *sessid);
static void cm_rtpbcast_process_switchers(cm_rtpbcast_rtp_source *src);
json_t *cm_rtpbcast_source_to_json(cm_rtpbcast_rtp_source *src, cm_rtpbcast_session *session);
json_t *cm_rtpbcast_sources_to_json(GArray *sources, cm_rtpbcast_session *session);
json_t *cm_rtpbcast_mountpoint_to_json(cm_rtpbcast_mountpoint *mountpoint, cm_rtpbcast_session *session);
json_t *cm_rtpbcast_mountpoints_to_json(cm_rtpbcast_session *session);

/* The idea is, keep pointers to sources in hash table and keep track of
	 available ports in the shuffled list. When a port is fred, it is inserted
	 at a random poisition back in the list, thus the computatonally intensive
	 operations are carried at startup and at source destruction only
	 */
static struct {
	GHashTable *used_ports;
	GList *free_ports;
	janus_mutex used_ports_mutex;
	guint ports_available;					/* GList doesn't keep track of size */
} port_manager;
static void cm_rtpbcast_port_manager_init();
static guint cm_rtpbcast_port_manager_assign(gpointer);
static void cm_rtpbcast_port_manager_free(guint);
static void cm_rtpbcast_port_manager_destroy();

static void cm_rtpbcast_mountpoint_free(cm_rtpbcast_mountpoint *mp);
static void cm_rtpbcast_mountpoint_destroy(gpointer data, gpointer user_data);

/* Helper to create an RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
typedef struct cm_rtpbcast_rtp_source_request {
	char *mcast[AV];
	uint8_t codec[AV];
	char *rtpmap[AV];
	char *fmtp[AV];
} cm_rtpbcast_rtp_source_request;

typedef struct cm_rtpbcast_rtp_relay_thread_data {
	cm_rtpbcast_mountpoint *mp;
	guint i;
} cm_rtpbcast_rtp_relay_thread_data;

cm_rtpbcast_mountpoint *cm_rtpbcast_create_rtp_source(
		char* id, char *name, char *desc, gboolean recorded,
		const char *allowed_ip, GArray *requests);

typedef struct cm_rtpbcast_message {
	janus_plugin_session *handle;
	char *transaction;
	json_t *message;
	char *sdp_type;
	char *sdp;
} cm_rtpbcast_message;
static GAsyncQueue *messages = NULL;

void cm_rtpbcast_message_free(cm_rtpbcast_message *msg);
void cm_rtpbcast_message_free(cm_rtpbcast_message *msg) {
	if(!msg)
		return;

	msg->handle = NULL;

	g_free(msg->transaction);
	msg->transaction = NULL;
	if(msg->message)
		json_decref(msg->message);
	msg->message = NULL;
	g_free(msg->sdp_type);
	msg->sdp_type = NULL;
	g_free(msg->sdp);
	msg->sdp = NULL;

	g_free(msg);
}

typedef struct cm_rtpbcast_context {
	/* Needed to fix seq and ts in case of stream switching */
	uint32_t last_ssrc[AV], last_ts[AV], base_ts[AV], base_ts_prev[AV];
	uint16_t last_seq[AV], base_seq[AV], base_seq_prev[AV];
} cm_rtpbcast_context;

typedef struct cm_rtpbcast_udp_relay_gateway {
	cm_rtpbcast_rtp_source *source;
	struct sockaddr_in sin[AV];
	gboolean valid[AV];
	int fd;
} cm_rtpbcast_udp_relay_gateway;

gboolean cm_rtpbcast_construct_address(char *hostname, int port, struct sockaddr_in *sin);

typedef struct cm_rtpbcast_session {
	janus_plugin_session *handle;
	cm_rtpbcast_rtp_source *source;
	cm_rtpbcast_rtp_source *nextsource; /* Source to switch after a keyframe */
	gboolean super_user;

	/* REMB and auxillary vars for math */
	guint64 remb;
	guint64 last_remb_usec;
	guint64 last_switch;
	gboolean autoswitch;

	GArray *relay_udp_gateways; /*cm_rtpbcast_udp_relay_gateway*/

	gboolean started;
	gboolean paused;
	cm_rtpbcast_context context;
	GList/*cm_rtpbcast_mountpoint*/ *mps;
	gboolean stopping;
	volatile gint hangingup;
	gint64 destroyed;	/* Time at which this session was marked as destroyed */

	janus_mutex mutex;
} cm_rtpbcast_session;
static GHashTable *sessions;
static GList *old_sessions;
static GList *super_sessions;
static janus_mutex sessions_mutex;
static void cm_rtpbcast_store_event(json_t* , const char *);
static void cm_rtpbcast_notify_supers(json_t*);
static void cm_rtpbcast_notify_session(gpointer, gpointer);
/* Stops UDP relays for the given session. Second parameter specifies the source pointer
 * which has a mutex locked within current context and thus doesn't need locking */
static void cm_rtpbcast_stop_udp_relays(cm_rtpbcast_session *, cm_rtpbcast_rtp_source *);

/* Packets we get from gstreamer and relay */
typedef struct cm_rtpbcast_rtp_relay_packet {
	rtp_header *data;
	gint length;
	gint is_video;
	guint source_index;
	uint32_t timestamp;
	uint16_t seq_number;
} cm_rtpbcast_rtp_relay_packet;

typedef struct cm_rtp_header_vp8
{
	/* RTP header */
#if __BYTE_ORDER == __BIG_ENDIAN
	uint16_t version:2;
	uint16_t padding:1;
	uint16_t extension:1;
	uint16_t csrccount:4;
	uint16_t markerbit:1;
	uint16_t type:7;
#elif __BYTE_ORDER == __LITTLE_ENDIAN
	uint16_t csrccount:4;
	uint16_t extension:1;
	uint16_t padding:1;
	uint16_t version:2;
	uint16_t type:7;
	uint16_t markerbit:1;
#endif
	uint16_t seq_number1:8;
	uint16_t seq_number2:8;
	uint32_t timestamp1:8;
	uint32_t timestamp2:8;
	uint32_t timestamp3:8;
	uint32_t timestamp4:8;
	uint32_t ssrc1:8;
	uint32_t ssrc2:8;
	uint32_t ssrc3:8;
	uint32_t ssrc4:8;
	/* RTP/VP8 header */
	/* 0x10 key-frame */
	/* 0x01 inter-frame */
	uint32_t byte0:8;
	uint32_t byte1:8;
	uint32_t byte2:8;
	uint32_t byte3:8;
	/* VP8 start bytes */
	/* 0x9d 0x01 0x2a */
	uint32_t magic0:8;
	uint32_t magic1:8;
	uint32_t magic2:8;
	/* VP8 width, height, scale-x, scale-y */
	uint32_t width0:8;
	uint32_t width1:8;
	uint32_t height0:8;
	uint32_t height1:8;
} cm_rtp_header_vp8;

/* Error codes */
#define CM_RTPBCAST_ERROR_NO_MESSAGE					450
#define CM_RTPBCAST_ERROR_INVALID_JSON				451
#define CM_RTPBCAST_ERROR_INVALID_REQUEST			452
#define CM_RTPBCAST_ERROR_MISSING_ELEMENT			453
#define CM_RTPBCAST_ERROR_INVALID_ELEMENT			454
#define CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT	455
#define CM_RTPBCAST_ERROR_CANT_CREATE					456
#define CM_RTPBCAST_ERROR_UNAUTHORIZED				457
#define CM_RTPBCAST_ERROR_CANT_SWITCH					458
#define CM_RTPBCAST_ERROR_UNKNOWN_ERROR				470

/* UDP relay queue */
typedef struct cm_rtpbcast_udp_relay_queue_node {
	void *data;
	guint len;
	struct sockaddr_in dst;
} cm_rtpbcast_udp_relay_queue_node;

GList* /* cm_rtpbcast_udp_relay_queue_node* */ udp_relay_queue;
janus_mutex udp_relay_mutex;

/* Puts a packet in the queue */
void cm_rtpbcast_udp_enqueue(void *data, guint len, struct sockaddr_in *dst) {
	/* Copy data over */
	cm_rtpbcast_udp_relay_queue_node *nd = g_malloc0(sizeof(cm_rtpbcast_udp_relay_queue_node));
	nd->len = len;
	nd->data = g_malloc0(len);
	memcpy(nd->data, data, len);
	memcpy(&nd->dst, dst, sizeof(struct sockaddr_in));

	/* Note this adds element from the front. Relay thread reverses the list.
	 * Also relay thread deallocates memory. */
	janus_mutex_lock(&udp_relay_mutex);
	udp_relay_queue = g_list_prepend(udp_relay_queue, nd);
	janus_mutex_unlock(&udp_relay_mutex);
}

/* FIXME: what to do if socket() fails and thread exists? */
void *cm_rtpbcast_udp_relay_thread(void *data) {
	JANUS_LOG(LOG_INFO, "UDP:Relay: thread started\n");

	/* As frugal as we are, only one socket for all the UDP */
	int fd;
	if ((fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {
		JANUS_LOG(LOG_ERR, "UDP:Relay: cannot create socket! Reason: %s\n", strerror(errno));
		return NULL;
	}

	/* On timer event, thread swaps udp_relay_queue with this one */
	/* @landswellsong: currently it just creates a fresh list each round. Maybe
	 * there is some rationale to send only certain amount of packets and
	 * swap queues? I can't tell upfront where the bottleneck is. */
	GList *queue = NULL;

	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		gint64 start = janus_get_monotonic_time();

		janus_mutex_lock(&udp_relay_mutex);
		queue = udp_relay_queue;
		udp_relay_queue = NULL;
		janus_mutex_unlock(&udp_relay_mutex);

		/* Elements are prepended for performance, traverse from the back */
		guint n = 0, success = 0;
		while (queue) {
				GList *last = g_list_last(queue);
				cm_rtpbcast_udp_relay_queue_node *nd = last->data;

				/* Send the packet */
				n++;
				if (sendto(fd, nd->data, nd->len, 0, (struct sockaddr *) &nd->dst, sizeof(struct sockaddr_in)) == -1)
					JANUS_LOG(LOG_ERR, "UDP:Relay: cannot send message! Reason %s\n", strerror(errno));
				else
					success++;

				/* Deallocate stuff */
				g_free(nd->data);
				g_free(nd);

				/* Remove the last one */
				queue = g_list_delete_link(queue, last);
		}

		gint64 ms_worked = janus_get_monotonic_time() - start;
		if (n > 0) {
			JANUS_LOG(LOG_HUGE, "UDP:Relay: done, queue was %d, sent %d successfully, job time %d usec.\n", n, success, ms_worked);
		}

		/* FIXME add configuration option */
		/* If we worked more than timeout, don't sleep. Otherwise sleep the remaining time */
		gint64 to_sleep = cm_rtpbcast_settings.udp_relay_interval - ms_worked;
		g_usleep(to_sleep > 0 ? to_sleep : 0);
	}

	/* FIXME: should we bother removing the queue too? */
	close(fd);

	return NULL;
}

/* Streaming watchdog/garbage collector (sort of) */
void *cm_rtpbcast_watchdog(void *data);
void *cm_rtpbcast_watchdog(void *data) {
	JANUS_LOG(LOG_INFO, "CM RTP Broadcast watchdog started\n");
	gint64 now = 0;
	gint64 session_update = 0;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		janus_mutex_lock(&sessions_mutex);
		/* Iterate on all the sessions */
		now = janus_get_monotonic_time();
		if(old_sessions != NULL) {
			GList *sl = old_sessions;
			JANUS_LOG(LOG_HUGE, "Checking %d old CM RTP Broadcast sessions...\n", g_list_length(old_sessions));
			while(sl) {
				cm_rtpbcast_session *session = (cm_rtpbcast_session *)sl->data;
				if(!session) {
					sl = sl->next;
					continue;
				}
				if(now-session->destroyed >= 5*G_USEC_PER_SEC) {
					/* We're lazy and actually get rid of the stuff only after a few seconds */
					JANUS_LOG(LOG_VERB, "Freeing old CM RTP Broadcast session\n");
					GList *rm = sl->next;
					old_sessions = g_list_delete_link(old_sessions, sl);
					sl = rm;
					session->handle = NULL;
					g_free(session);
					session = NULL;
					continue;
				}
				sl = sl->next;
			}
		}

		if (now-session_update >= cm_rtpbcast_settings.mountpoint_info_interval * G_USEC_PER_SEC) {
			if(sessions && g_hash_table_size(sessions) > 0) {
				GHashTableIter iter;
				gpointer value;
				g_hash_table_iter_init(&iter, sessions);
				while (g_hash_table_iter_next(&iter, NULL, &value)) {
					cm_rtpbcast_session *session = (cm_rtpbcast_session *) value;
					if (!session || session->stopping || session->paused) {
						continue;
					}
					if (session->source != NULL) {
						json_t *event = json_object();
						json_t *result = json_object();

						json_object_set_new(event, "streaming", json_string("event"));
						json_object_set_new(result, "event", json_string("mountpoint-info"));

						json_t *st = cm_rtpbcast_sources_to_json(session->source->mp->sources, session);
						json_object_set_new(result, "streams", st);

						json_t *config = json_object();
						json_object_set_new(config, "mountpoint-info-interval", json_integer(cm_rtpbcast_settings.mountpoint_info_interval));
						json_object_set_new(result, "config", config);

						json_object_set_new(event, "result", result);
						char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
						gateway->push_event(session->handle, &cm_rtpbcast_plugin, NULL, event_text, NULL, NULL);
					}
				}
			}
			session_update = janus_get_monotonic_time();
		}

		janus_mutex_unlock(&sessions_mutex);
		janus_mutex_lock(&mountpoints_mutex);
		/* Iterate on all the mountpoints */
		if(old_mountpoints != NULL) {
			GList *sl = old_mountpoints;
			JANUS_LOG(LOG_HUGE, "Checking %d old CM RTP Broadcast mountpoints...\n", g_list_length(old_mountpoints));
			while(sl) {
				cm_rtpbcast_mountpoint *mountpoint = (cm_rtpbcast_mountpoint *)sl->data;
				if(!mountpoint) {
					sl = sl->next;
					continue;
				}
				if(now-mountpoint->destroyed >= 5*G_USEC_PER_SEC) {
					/* We're lazy and actually get rid of the stuff only after a few seconds */
					JANUS_LOG(LOG_VERB, "Freeing old CM RTP Broadcast mountpoint\n");
					GList *rm = sl->next;
					old_mountpoints = g_list_delete_link(old_mountpoints, sl);
					sl = rm;
					cm_rtpbcast_mountpoint_free(mountpoint);
					mountpoint = NULL;
					continue;
				}
				sl = sl->next;
			}
		}
		janus_mutex_unlock(&mountpoints_mutex);
		g_usleep(500000);
	}
	JANUS_LOG(LOG_INFO, "CM RTP Broadcast watchdog stopped\n");
	return NULL;
}


/* Plugin implementation */
int cm_rtpbcast_init(janus_callbacks *callback, const char *config_path) {
	if(g_atomic_int_get(&stopping)) {
		/* Still stopping from before */
		return -1;
	}
	if(callback == NULL || config_path == NULL) {
		/* Invalid arguments */
		return -1;
	}

	/* Read configuration */
	char filename[255];
	g_snprintf(filename, 255, "%s/%s.cfg", config_path, CM_RTPBCAST_PACKAGE);
	JANUS_LOG(LOG_VERB, "Configuration file: %s\n", filename);
	janus_config *config = janus_config_parse(filename);
	if(config != NULL)
		janus_config_print(config);

	/* Defauts */
	cm_rtpbcast_settings.hostname = g_strdup("localhost");
	cm_rtpbcast_settings.minport = 8000;
	cm_rtpbcast_settings.maxport = 9000;
	cm_rtpbcast_settings.mountpoint_info_interval = 10;
	cm_rtpbcast_settings.udp_relay_interval = 50000;
	cm_rtpbcast_settings.job_path = g_strdup("/tmp/jobs");
	cm_rtpbcast_settings.job_pattern = g_strdup("job-#{md5}");
	cm_rtpbcast_settings.archive_path =  g_strdup("/tmp/recordings");
	cm_rtpbcast_settings.recording_pattern = g_strdup("rec-#{id}-#{time}-#{type}");
	cm_rtpbcast_settings.thumbnailing_pattern = g_strdup("thum-#{id}-#{time}-#{type}");
	cm_rtpbcast_settings.thumbnailing_interval = 60;
	cm_rtpbcast_settings.thumbnailing_duration = 10;
	cm_rtpbcast_settings.keyframe_distance_alert = 600;
	cm_rtpbcast_settings.recording_enabled = TRUE;
	cm_rtpbcast_settings.simulate_bad_connection = FALSE;
	cm_rtpbcast_settings.packet_loss_rate = 0;
	cm_rtpbcast_settings.udp_relay_queue_enabled = FALSE;
	cm_rtpbcast_settings.autoswitch = FALSE;

	mountpoints = g_hash_table_new_full(
		g_str_hash,	 /* Hashing func */
		g_str_equal, /* Key comparator */
		g_free,			 /* Key destructor */
		NULL);			 /* Value destructor, we don't want this done automatically */
	janus_mutex_init(&mountpoints_mutex);
	/* Parse configuration to populate the mountpoints */
	if(config != NULL) {
		/* Boolean */
		{
			const char *inames [] = {
				"recording_enabled",
				"simulate_bad_connection",
				"udp_relay_queue_enabled",
				"autoswitch",
			};
			gboolean *ivars [] = {
				&cm_rtpbcast_settings.recording_enabled,
				&cm_rtpbcast_settings.simulate_bad_connection,
				&cm_rtpbcast_settings.udp_relay_queue_enabled,
				&cm_rtpbcast_settings.autoswitch,
			};

			_foreach(i, ivars) {
				janus_config_item *itm = janus_config_get_item_drilldown(config, "general", inames[i]);
				if (itm && itm->value) {
					*ivars[i] = janus_is_true(itm->value);
				}
			}
		}
		/* Integers */
		{
			const char *inames [] = {
				"minport",
				"maxport",
				"thumbnailing_interval",
				"thumbnailing_duration",
				"mountpoint_info_interval",
				"keyframe_distance_alert",
				"packet_loss_rate",
				"udp_relay_interval",
			};
			guint *ivars [] = {
				&cm_rtpbcast_settings.minport,
				&cm_rtpbcast_settings.maxport,
				&cm_rtpbcast_settings.thumbnailing_interval,
				&cm_rtpbcast_settings.thumbnailing_duration,
				&cm_rtpbcast_settings.mountpoint_info_interval,
				&cm_rtpbcast_settings.keyframe_distance_alert,
				&cm_rtpbcast_settings.packet_loss_rate,
				&cm_rtpbcast_settings.udp_relay_interval,
			};

			_foreach(i, ivars) {
				janus_config_item *itm = janus_config_get_item_drilldown(config, "general", inames[i]);
				if (itm && itm->value) {
					guint res = g_ascii_strtoull(itm->value, NULL, 10);
					if (res != 0)
						*ivars[i] = res;
				}
			}
		}
		/* Strings */
		{
			const char *inames [] = {
			 "hostname",
			 "job_path",
			 "job_pattern",
			 "archive_path",
			 "recording_pattern",
			 "thumbnailing_pattern"
		  };
			const char **ivars [] = {
				&cm_rtpbcast_settings.hostname,
				&cm_rtpbcast_settings.job_path,
				&cm_rtpbcast_settings.job_pattern,
				&cm_rtpbcast_settings.archive_path,
				&cm_rtpbcast_settings.recording_pattern,
				&cm_rtpbcast_settings.thumbnailing_pattern
			};

			_foreach(i, ivars) {
				janus_config_item *itm = janus_config_get_item_drilldown(config, "general", inames[i]);
				if (itm && itm->value) {
					g_free((gpointer)*ivars[i]);
					*ivars[i] = g_strdup(itm->value);
				}
			}
		}

		if(cm_rtpbcast_settings.minport > cm_rtpbcast_settings.maxport) {
			g_atomic_int_set(&initialized, 0);
			JANUS_LOG(LOG_ERR, "Configuration error: minport %d is bigger than maxport %d\n",
				cm_rtpbcast_settings.minport, cm_rtpbcast_settings.maxport);
			return -1;
		}

		/* Done */
		janus_config_destroy(config);
		config = NULL;
	}
	cm_rtpbcast_port_manager_init(cm_rtpbcast_settings.minport, cm_rtpbcast_settings.maxport);

	/* Not showing anything, no mountpoint configured at startup */
	sessions = g_hash_table_new(NULL, NULL);
	super_sessions = NULL;
	janus_mutex_init(&sessions_mutex);
	messages = g_async_queue_new_full((GDestroyNotify) cm_rtpbcast_message_free);
	/* This is the callback we'll need to invoke to contact the gateway */
	gateway = callback;
	g_atomic_int_set(&initialized, 1);

	GError *error = NULL;
	/* Start the sessions watchdog */
	watchdog = g_thread_try_new("rtpbroadcast watchdog", &cm_rtpbcast_watchdog, NULL, &error);
	if(!watchdog) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the RTP broadcast watchdog thread...\n", error->code, error->message ? error->message : "??");
		return -1;
	}
	/* Start the UDP relay thread */
	janus_mutex_init(&udp_relay_mutex);
	udp_relay_queue = NULL;
	if (cm_rtpbcast_settings.udp_relay_queue_enabled) {
		udp_relay = g_thread_try_new("rtpbroadcast udp relay", &cm_rtpbcast_udp_relay_thread, NULL, &error);
		if(!udp_relay) {
			g_atomic_int_set(&initialized, 0);
			JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the RTP broadcast UDP relay thread...\n", error->code, error->message ? error->message : "??");
			return -1;
		}
	}
	/* Launch the thread that will handle incoming messages */
	handler_thread = g_thread_try_new("janus rtpbroadcast handler", cm_rtpbcast_handler, NULL, &error);
	if(error != NULL) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the RTP broadcast handler thread...\n", error->code, error->message ? error->message : "??");
		return -1;
	}
	JANUS_LOG(LOG_INFO, "%s initialized!\n", CM_RTPBCAST_NAME);
	return 0;
}

void cm_rtpbcast_destroy(void) {
	if(!g_atomic_int_get(&initialized))
		return;
	g_atomic_int_set(&stopping, 1);

	if(handler_thread != NULL) {
		g_thread_join(handler_thread);
		handler_thread = NULL;
	}

	/* Remove all mountpoints */
	janus_mutex_unlock(&mountpoints_mutex);
	GHashTableIter iter;
	gpointer value;
	g_hash_table_iter_init(&iter, mountpoints);
	while (g_hash_table_iter_next(&iter, NULL, &value)) {
		cm_rtpbcast_mountpoint *mp = value;
		if(!mp->destroyed) {
			mp->destroyed = janus_get_monotonic_time();
			old_mountpoints = g_list_append(old_mountpoints, mp);
		}
	}
	janus_mutex_unlock(&mountpoints_mutex);
	if(watchdog != NULL) {
		g_thread_join(watchdog);
		watchdog = NULL;
	}

	/* FIXME We should destroy the sessions cleanly */
	usleep(500000);
	janus_mutex_lock(&mountpoints_mutex);
	g_hash_table_destroy(mountpoints); /* TODO: @landswellsong do we need to free them? */
	janus_mutex_unlock(&mountpoints_mutex);
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_destroy(sessions);
	janus_mutex_unlock(&sessions_mutex);
	cm_rtpbcast_port_manager_destroy();
	g_async_queue_unref(messages);
	messages = NULL;
	sessions = NULL;

	/* Freeing configuration strings */
	g_free((gpointer)cm_rtpbcast_settings.hostname);
	g_free((gpointer)cm_rtpbcast_settings.job_path);
	g_free((gpointer)cm_rtpbcast_settings.job_pattern);
	g_free((gpointer)cm_rtpbcast_settings.archive_path);
	g_free((gpointer)cm_rtpbcast_settings.recording_pattern);
	g_free((gpointer)cm_rtpbcast_settings.thumbnailing_pattern);

	g_atomic_int_set(&initialized, 0);
	g_atomic_int_set(&stopping, 0);
	JANUS_LOG(LOG_INFO, "%s destroyed!\n", CM_RTPBCAST_NAME);
}

int cm_rtpbcast_get_api_compatibility(void) {
	/* Important! This is what your plugin MUST always return: don't lie here or bad things will happen */
	return JANUS_PLUGIN_API_VERSION;
}

int cm_rtpbcast_get_version(void) {
	return CM_RTPBCAST_VERSION;
}

const char *cm_rtpbcast_get_version_string(void) {
	return CM_RTPBCAST_VERSION_STRING;
}

const char *cm_rtpbcast_get_description(void) {
	return CM_RTPBCAST_DESCRIPTION;
}

const char *cm_rtpbcast_get_name(void) {
	return CM_RTPBCAST_NAME;
}

const char *cm_rtpbcast_get_author(void) {
	return CM_RTPBCAST_AUTHOR;
}

const char *cm_rtpbcast_get_package(void) {
	return CM_RTPBCAST_PACKAGE;
}

void cm_rtpbcast_create_session(janus_plugin_session *handle, int *error) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}

	cm_rtpbcast_session *session = (cm_rtpbcast_session *)g_malloc0(sizeof(cm_rtpbcast_session));

	if(session == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		*error = -2;
		return;
	}
	session->handle = handle;
	session->source = NULL;	/* This will happen later */
	session->nextsource = NULL;
	session->started = FALSE;	/* This will happen later */
	session->paused = FALSE;
	session->destroyed = 0;
	session->remb = -1;
	session->last_remb_usec = 0;
	session->last_switch = janus_get_monotonic_time();
	session->mps = NULL;
	session->autoswitch = cm_rtpbcast_settings.autoswitch;
	session->relay_udp_gateways = NULL;
	session->super_user = FALSE;
	janus_mutex_init(&session->mutex);

	g_atomic_int_set(&session->hangingup, 0);
	handle->plugin_handle = session;
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_insert(sessions, handle, session);
	janus_mutex_unlock(&sessions_mutex);

	return;
}

void cm_rtpbcast_destroy_session(janus_plugin_session *handle, int *error) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}
	cm_rtpbcast_session *session = (cm_rtpbcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		*error = -2;
		return;
	}
	JANUS_LOG(LOG_VERB, "Removing CM RTP Broadcast session...\n");
	/* If session is watching something, remove it from listeners */
	/* TODO: abstract "attach to source" and "remove from source" with a special func
	 * also see below at cm_rtpbcast_stop_udp_relays() for example */
	if(session->source) {
		janus_mutex_lock(&session->source->mutex);
		session->source->listeners = g_list_remove_all(session->source->listeners, session);
		janus_mutex_unlock(&session->source->mutex);
	}
	/* If the session is relaying UDP, also remove listeners from all the sources */
	cm_rtpbcast_stop_udp_relays(session, NULL);

	/* If this is a streamer session, kill the stream */
	if(session->mps)
		g_list_foreach(session->mps, cm_rtpbcast_mountpoint_destroy, NULL);
	session->mps = NULL;

	janus_mutex_lock(&sessions_mutex);
	if(!session->destroyed) {
		session->destroyed = janus_get_monotonic_time();
		g_hash_table_remove(sessions, handle);
		super_sessions = g_list_remove_all(super_sessions, session);
		/* Cleaning up and removing the session is done in a lazy way */
		old_sessions = g_list_append(old_sessions, session);
	}
	janus_mutex_unlock(&sessions_mutex);
	return;
}

char *cm_rtpbcast_query_session(janus_plugin_session *handle) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		return NULL;
	}
	cm_rtpbcast_session *session = (cm_rtpbcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return NULL;
	}
	/* What is this user watching, if anything? */
	json_t *info = json_object();
	json_object_set_new(info, "state", json_string(session->source ? "watching" : "idle"));
	if(session->source) {
		/* TODO @landswellsong maybe also dump the # of the stream itself? */
		json_object_set_new(info, "mountpoint_id", json_string(session->source->mp->id));
		json_object_set_new(info, "mountpoint_name", session->source->mp->name ? json_string(session->source->mp->name) : NULL);
	}
	json_object_set_new(info, "destroyed", json_integer(session->destroyed));
	char *info_text = json_dumps(info, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
	json_decref(info);
	return info_text;
}

struct janus_plugin_result *cm_rtpbcast_handle_message(janus_plugin_session *handle, char *transaction, char *message, char *sdp_type, char *sdp) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return janus_plugin_result_new(JANUS_PLUGIN_ERROR, g_atomic_int_get(&stopping) ? "Shutting down" : "Plugin not initialized");

	/* Pre-parse the message */
	int error_code = 0;
	char error_cause[512];
	json_t *root = NULL;
	json_t *response = NULL;

	/* This might need to be freed at error: label */
	GArray *sources = NULL;

	if(message == NULL) {
		JANUS_LOG(LOG_ERR, "No message??\n");
		error_code = CM_RTPBCAST_ERROR_NO_MESSAGE;
		g_snprintf(error_cause, 512, "%s", "No message??");
		goto error;
	}
	JANUS_LOG(LOG_VERB, "Handling message: %s\n", message);

	cm_rtpbcast_session *session = (cm_rtpbcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		error_code = CM_RTPBCAST_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "session associated with this handle...");
		goto error;
	}
	if(session->destroyed) {
		JANUS_LOG(LOG_ERR, "Session has already been destroyed...\n");
		error_code = CM_RTPBCAST_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "Session has already been destroyed...");
		goto error;
	}
	json_error_t error;
	root = json_loads(message, 0, &error);
	if(!root) {
		JANUS_LOG(LOG_ERR, "JSON error: on line %d: %s\n", error.line, error.text);
		error_code = CM_RTPBCAST_ERROR_INVALID_JSON;
		g_snprintf(error_cause, 512, "JSON error: on line %d: %s", error.line, error.text);
		goto error;
	}
	if(!json_is_object(root)) {
		JANUS_LOG(LOG_ERR, "JSON error: not an object\n");
		error_code = CM_RTPBCAST_ERROR_INVALID_JSON;
		g_snprintf(error_cause, 512, "JSON error: not an object");
		goto error;
	}
	/* Get the request first */
	json_t *request = json_object_get(root, "request");
	if(!request) {
		JANUS_LOG(LOG_ERR, "Missing element (request)\n");
		error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
		g_snprintf(error_cause, 512, "Missing element (request)");
		goto error;
	}
	if(!json_is_string(request)) {
		JANUS_LOG(LOG_ERR, "Invalid element (request should be a string)\n");
		error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
		g_snprintf(error_cause, 512, "Invalid element (request should be a string)");
		goto error;
	}
	/* Some requests ('create' and 'destroy') can be handled synchronously */
	const char *request_text = json_string_value(request);
	if(!strcasecmp(request_text, "superuser")) {
		/* TODO @landswellsong layer authentication over that */
		json_t *value = json_object_get(root, "enabled");
		if(!value) {
			JANUS_LOG(LOG_ERR, "Missing element (value)\n");
			error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (value)");
			goto error;
		}
		if(!json_is_boolean(value)) {
			JANUS_LOG(LOG_ERR, "Invalid element (value should be boolean)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (value should be boolean)");
			goto error;
		}

		gboolean su = json_is_true(value);

		if (session->super_user != su) {
			if (su) {
				super_sessions = g_list_prepend(super_sessions, session);
			} else {
				super_sessions = g_list_remove_all(super_sessions, session);
			}
			session->super_user = su;
		}

		response = json_object();
		json_object_set_new(response, "streaming", json_string("superuser"));
		json_object_set_new(response, "enabled", json_integer(session->super_user));
		goto plugin_response;
	} else if(!strcasecmp(request_text, "list")) {
		json_t *id = json_object_get(root, "id");
		if(id && !json_is_string(id) < 0) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
			goto error;
		}

		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("list"));
		json_object_set_new(response, "list", cm_rtpbcast_mountpoints_to_json(session));
		goto plugin_response;
	} else if(!strcasecmp(request_text, "create")) {
		/* Create a new stream */
		cm_rtpbcast_mountpoint *mp = NULL;

		/* RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_string(id)) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
			goto error;
		}
		json_t *name = json_object_get(root, "name");
		if(name && !json_is_string(name)) {
			JANUS_LOG(LOG_ERR, "Invalid element (name should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (name should be a string)");
			goto error;
		}
		json_t *desc = json_object_get(root, "description");
		if(desc && !json_is_string(desc)) {
			JANUS_LOG(LOG_ERR, "Invalid element (desc should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (desc should be a string)");
			goto error;
		}
		json_t *recorded = json_object_get(root, "recorded");
		if(recorded && !json_is_boolean(recorded)) {
			JANUS_LOG(LOG_ERR, "Invalid element (recorded should be a boolean)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (recorded should be a boolean)");
			goto error;
		}
		json_t *whitelist = json_object_get(root, "whitelist");
		if(whitelist && !json_is_string(whitelist)) {
			JANUS_LOG(LOG_ERR, "Invalid element (whitelist should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (whitelist should be a string)");
			goto error;
		}

		/* Streams is an array now, containing pairs of audio+video streams */
		json_t *streams = json_object_get(root, "streams");
		size_t nstreams = json_array_size(streams);
		if (nstreams==0 || !json_is_array(streams)) {
			JANUS_LOG(LOG_ERR, "Invalid element (streams should be a non-empty array)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (streams should be a non-empty array)");
			goto error;
		}

		sources = g_array_sized_new(FALSE, FALSE,
			sizeof(cm_rtpbcast_rtp_source_request), nstreams);
		size_t i;
		json_t *v;

		/* Jansson's nomenclature changed a bit between versions */
#ifdef json_array_foreach
		json_array_foreach(streams, i, v) {
#else
		for (i = 0; i < json_array_size(streams); i++) {
			v = json_array_get(streams, i);
#endif
			if (v && !json_is_object(v)) {
				JANUS_LOG(LOG_ERR, "Invalid element (streams elements should be objects)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid value (streams elements should be objects)");
				goto error;
			}

			cm_rtpbcast_rtp_source_request req = {
				NULL, NULL,
				0, 0,
				NULL, NULL,
				NULL, NULL,
			}; /* FIXME @landswellsong check if it's correct initialization */

			/* Audio/Video stream params */
			size_t j;
			for (j = AUDIO; j <= VIDEO; j++) {
				char tmpnm[512];

				g_snprintf(tmpnm, 512, "%smcast", av_names[j]);
				json_t *mcast = json_object_get(v, tmpnm);
				if(mcast && !json_is_string(mcast)) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a string)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a string)", tmpnm);
					goto error;
				} else {
					req.mcast[j] = (char *)json_string_value(mcast);
				}

				g_snprintf(tmpnm, 512, "%spt", av_names[j]);
				json_t *pt = json_object_get(v, tmpnm);
				if(!pt) {
					JANUS_LOG(LOG_ERR, "Missing element (%s)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (%s)", tmpnm);
					goto error;
				}
				if(!json_is_integer(pt) || json_integer_value(pt) < 0) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a positive integer)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a positive integer)", tmpnm);
					goto error;
				}
				req.codec[j] = json_integer_value(pt);

				g_snprintf(tmpnm, 512, "%srtpmap", av_names[j]);
				json_t *rtpmap = json_object_get(v, tmpnm);
				if(!rtpmap) {
					JANUS_LOG(LOG_ERR, "Missing element (%s)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (%s)", tmpnm);
					goto error;
				}
				if(!json_is_string(rtpmap)) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a string)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a string)", tmpnm);
					goto error;
				}
				req.rtpmap[j] = (char *)json_string_value(rtpmap);

				g_snprintf(tmpnm, 512, "%sfmtp", av_names[j]);
				json_t *fmtp = json_object_get(v, tmpnm);
				if(fmtp && !json_is_string(fmtp)) {
					JANUS_LOG(LOG_ERR, "Invalid element (%s should be a string)\n", tmpnm);
					error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (%s should be a string)", tmpnm);
					goto error;
				}
				req.fmtp[j] = (char *)json_string_value(fmtp);
			}
			/* All done, append to array */
			g_array_append_val(sources, req);
		}
		if(id == NULL) {
			JANUS_LOG(LOG_VERB, "Missing id, will generate a random one...\n");
		} else {
			janus_mutex_lock(&mountpoints_mutex);
			mp = g_hash_table_lookup(mountpoints, json_string_value(id));
			janus_mutex_unlock(&mountpoints_mutex);
			if(mp != NULL) {
				JANUS_LOG(LOG_ERR, "A stream with the provided ID already exists\n");
				error_code = CM_RTPBCAST_ERROR_CANT_CREATE;
				g_snprintf(error_cause, 512, "A stream with the provided ID already exists");
				goto error;
			}
		}
		mp = cm_rtpbcast_create_rtp_source(
				id ? (char *)json_string_value(id) : NULL,
				name ? (char *)json_string_value(name) : NULL,
				desc ? (char *)json_string_value(desc) : NULL,
				cm_rtpbcast_settings.recording_enabled ? (recorded && json_is_true(recorded)) : FALSE,
				whitelist ? json_string_value(whitelist) : NULL,
				sources);
		if(mp == NULL) {
			JANUS_LOG(LOG_ERR, "Error creating 'rtp' stream...\n");
			error_code = CM_RTPBCAST_ERROR_CANT_CREATE;
			g_snprintf(error_cause, 512, "Error creating 'rtp' stream");
			goto error;
		}

		/* Associate mp with session */
		session->mps = g_list_prepend(session->mps, mp);
		mp->session = session;

		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("created"));
		json_object_set_new(response, "created", json_string(mp->name));
		json_t *ml = json_object();
		json_object_set_new(ml, "id", json_string(mp->id));
		json_object_set_new(ml, "uid", json_string(mp->uid));
		json_object_set_new(ml, "description", json_string(mp->description));
/*		json_object_set_new(ml, "streamcount", json_integer(nstreams)); */
		json_t *st = json_array();
		for (i = 0; i < mp->sources->len; i++) {
			json_t *v = json_object();
			json_t *audio = json_object();
			json_t *video = json_object();

			json_object_set_new(audio, "port", json_integer(g_array_index(mp->sources, cm_rtpbcast_rtp_source*, i)->port[AUDIO]));
			json_object_set_new(audio, "host", json_string(g_strdup(cm_rtpbcast_settings.hostname)));
			json_object_set_new(video, "port", json_integer(g_array_index(mp->sources, cm_rtpbcast_rtp_source*, i)->port[VIDEO]));
			json_object_set_new(video, "host", json_string(g_strdup(cm_rtpbcast_settings.hostname)));

			json_object_set_new(v, "audio", audio);
			json_object_set_new(v, "video", video);
			json_array_append_new(st, v);
		}
		json_object_set_new(ml, "streams", st);
		json_object_set_new(response, "stream", ml);

		json_t *event = json_object();
		json_t *result = json_object();
		json_object_set_new(event, "streaming", json_string("event"));
		json_object_set_new(result, "event", json_string("mountpoints-info"));
		json_object_set_new(result, "list", cm_rtpbcast_mountpoints_to_json(session));
		json_object_set_new(event, "result", result);
		cm_rtpbcast_notify_supers(event);

		goto plugin_response;
	} else if(!strcasecmp(request_text, "destroy")) {
		/* Get rid of an existing stream (notice this doesn't remove it from the config file, though) */
		json_t *id = json_object_get(root, "id");
		if(!id) {
			JANUS_LOG(LOG_ERR, "Missing element (id)\n");
			error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (id)");
			goto error;
		}
		if(!json_is_string(id) < 0) {
			JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
			goto error;
		}
		const char *id_value = json_string_value(id);
		janus_mutex_lock(&mountpoints_mutex);
		cm_rtpbcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
		if(mp == NULL) {
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
			error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
			g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
			goto error;
		}
		JANUS_LOG(LOG_VERB, "Request to unmount mountpoint/stream %s\n", id_value);
		cm_rtpbcast_mountpoint_destroy(mp, NULL);
		janus_mutex_unlock(&mountpoints_mutex);
		/* Send info back */
		response = json_object();
		json_object_set_new(response, "streaming", json_string("destroyed"));
		json_object_set_new(response, "destroyed", json_string(id_value));

		json_t *event = json_object();
		json_t *result = json_object();
		json_object_set_new(event, "streaming", json_string("event"));
		json_object_set_new(result, "event", json_string("mountpoints-info"));
		json_object_set_new(result, "list", cm_rtpbcast_mountpoints_to_json(session));
		json_object_set_new(event, "result", result);
		cm_rtpbcast_notify_supers(event);

		goto plugin_response;
	} else if(!strcasecmp(request_text, "watch") || !strcasecmp(request_text, "watch-udp") || !strcasecmp(request_text, "start")
			|| !strcasecmp(request_text, "pause") || !strcasecmp(request_text, "stop")
			|| !strcasecmp(request_text, "switch") || !strcasecmp(request_text, "switch-source")) {
		/* These messages are handled asynchronously */
		cm_rtpbcast_message *msg = g_malloc0(sizeof(cm_rtpbcast_message));
		if(msg == NULL) {
			JANUS_LOG(LOG_FATAL, "Memory error!\n");
			error_code = CM_RTPBCAST_ERROR_UNKNOWN_ERROR;
			g_snprintf(error_cause, 512, "Memory error");
			goto error;
		}

		g_free(message);
		msg->handle = handle;
		msg->transaction = transaction;
		msg->message = root;
		msg->sdp_type = sdp_type;
		msg->sdp = sdp;

		g_async_queue_push(messages, msg);

		return janus_plugin_result_new(JANUS_PLUGIN_OK_WAIT, NULL);
	} else {
		JANUS_LOG(LOG_VERB, "Unknown request '%s'\n", request_text);
		error_code = CM_RTPBCAST_ERROR_INVALID_REQUEST;
		g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
		goto error;
	}

plugin_response:
		{
			if(!response) {
				error_code = CM_RTPBCAST_ERROR_UNKNOWN_ERROR;
				g_snprintf(error_cause, 512, "Invalid response");
				goto error;
			}
			if(root != NULL)
				json_decref(root);
			g_free(transaction);
			g_free(message);
			g_free(sdp_type);
			g_free(sdp);

			if (sources != NULL)
				g_array_free(sources, TRUE);

			char *response_text = json_dumps(response, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(response);
			janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, response_text);
			g_free(response_text);
			return result;
		}

error:
		{
			if(root != NULL)
				json_decref(root);
			g_free(transaction);
			g_free(message);
			g_free(sdp_type);
			g_free(sdp);

			if (sources != NULL)
				g_array_free(sources, TRUE);

			/* Prepare JSON error event */
			json_t *event = json_object();
			json_object_set_new(event, "streaming", json_string("event"));
			json_object_set_new(event, "error_code", json_integer(error_code));
			json_object_set_new(event, "error", json_string(error_cause));
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, event_text);
			g_free(event_text);
			return result;
		}

}

void cm_rtpbcast_setup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "WebRTC media is now available\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	cm_rtpbcast_session *session = (cm_rtpbcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	if(session->destroyed)
		return;
	g_atomic_int_set(&session->hangingup, 0);
	/* TODO Only start streaming when we get this event */
	memset(&session->context, 0, sizeof(session->context));
	session->started = TRUE;
	/* Prepare JSON event */
	json_t *event = json_object();
	json_object_set_new(event, "streaming", json_string("event"));
	json_t *result = json_object();
	json_object_set_new(result, "status", json_string("started"));
	json_object_set_new(event, "result", result);
	char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
	json_decref(event);
	JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
	int ret = gateway->push_event(handle, &cm_rtpbcast_plugin, NULL, event_text, NULL, NULL);
	JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
	g_free(event_text);
}

void cm_rtpbcast_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len) {
	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	/* FIXME We don't care about what the browser sends us, we're sendonly */
}

void cm_rtpbcast_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len) {
	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	/* Get the session */
	janus_mutex_lock(&sessions_mutex);
	cm_rtpbcast_session *sessid = g_hash_table_lookup(sessions, handle);
	janus_mutex_unlock(&sessions_mutex);

	/* If session not found, abort, TODO @landswellsong maybe complain in the log */
	if (sessid == NULL)
		return;

	if (sessid->stopping || sessid->paused)
		return;

	/* We might interested in the available bandwidth that the user advertizes */
	uint64_t bw = janus_rtcp_get_remb(buf, len);
	if(bw > 0) {
		JANUS_LOG(LOG_HUGE, "REMB for this PeerConnection: %"SCNu64"\n", bw);

		/* If it's first measurement, start the timer */
		guint64 ml = janus_get_monotonic_time();

		/* Calculate average */
		sessid->remb = bw;
		sessid->last_remb_usec = ml;

		/* If the session is watching something, let's see if it needs switching */
		if (sessid->source && sessid->autoswitch) {

			if (sessid->source == NULL)
				return;

			if (sessid->source->mp == NULL)
				return;

			if (sessid->source->mp->sources == NULL)
				return;

			janus_mutex_lock(&mountpoints_mutex);

			janus_mutex_lock(&sessid->source->mutex);
			cm_rtpbcast_rtp_source *src =
				cm_rtpbcast_pick_source(sessid->source->mp->sources, sessid->remb);
			janus_mutex_unlock(&sessid->source->mutex);

			/* Check if we really need to switch */
			if (src && src != sessid->source) {
				cm_rtpbcast_schedule_switch(sessid, src);

				sessid->last_switch = ml;
			}

			janus_mutex_unlock(&mountpoints_mutex);
		}
	}
	/* FIXME Maybe we should care about RTCP, but not now */
}

void cm_rtpbcast_hangup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "No WebRTC media anymore\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	cm_rtpbcast_session *session = (cm_rtpbcast_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	if(session->destroyed)
		return;
	if(g_atomic_int_add(&session->hangingup, 1))
		return;
	/* FIXME Simulate a "stop" coming from the browser */
	cm_rtpbcast_message *msg = g_malloc0(sizeof(cm_rtpbcast_message));
	msg->handle = handle;
	msg->message = json_loads("{\"request\":\"stop\"}", 0, NULL);
	msg->transaction = NULL;
	msg->sdp_type = NULL;
	msg->sdp = NULL;
	g_async_queue_push(messages, msg);
}

/* Thread to handle incoming messages */
static void *cm_rtpbcast_handler(void *data) {
	JANUS_LOG(LOG_VERB, "Joining CM RTP Broadcast handler thread\n");
	cm_rtpbcast_message *msg = NULL;
	int error_code = 0;
	char *error_cause = g_malloc0(1024);
	if(error_cause == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		return NULL;
	}
	json_t *root = NULL;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		if(!messages || (msg = g_async_queue_try_pop(messages)) == NULL) {
			usleep(50000);
			continue;
		}
		cm_rtpbcast_session *session = (cm_rtpbcast_session *)msg->handle->plugin_handle;
		if(!session) {
			JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
			cm_rtpbcast_message_free(msg);
			continue;
		}
		if(session->destroyed) {
			cm_rtpbcast_message_free(msg);
			continue;
		}
		/* Handle request */
		error_code = 0;
		root = NULL;
		if(msg->message == NULL) {
			JANUS_LOG(LOG_ERR, "No message??\n");
			error_code = CM_RTPBCAST_ERROR_NO_MESSAGE;
			g_snprintf(error_cause, 512, "%s", "No message??");
			goto error;
		}
		root = msg->message;
		/* Get the request first */
		json_t *request = json_object_get(root, "request");
		if(!request) {
			JANUS_LOG(LOG_ERR, "Missing element (request)\n");
			error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (request)");
			goto error;
		}
		if(!json_is_string(request)) {
			JANUS_LOG(LOG_ERR, "Invalid element (request should be a string)\n");
			error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (request should be a string)");
			goto error;
		}
		const char *request_text = json_string_value(request);
		json_t *result = NULL;
		const char *sdp_type = NULL;
		char *sdp = NULL;
		/* All these requests can only be handled asynchronously */
		if(!strcasecmp(request_text, "watch")) {
			json_t *id = json_object_get(root, "id");
			if(!id) {
				JANUS_LOG(LOG_ERR, "Missing element (id)\n");
				error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (id)");
				goto error;
			}
			if(!json_is_string(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
				goto error;
			}
			const char *id_value = json_string_value(id);
			janus_mutex_lock(&mountpoints_mutex);
			cm_rtpbcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
			if(mp == NULL) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
				goto error;
			}
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "Request to watch mountpoint/stream %s\n", id_value);
			session->stopping = FALSE;

			session->source = cm_rtpbcast_pick_source(mp->sources, session->remb);
			cm_rtpbcast_rtp_source *src = session->source;

			/* TODO Check if user is already watching a stream, if the video is active, etc. */
			/* TODO @landswellsong cover these original TODOs */
			/* TODO @landswellsong make sure "switch" and "auto-switch" send SDPs with correct codecs */
			janus_mutex_lock(&src->mutex);
			src->listeners = g_list_append(src->listeners, session);
			janus_mutex_unlock(&src->mutex);
			sdp_type = "offer";	/* We're always going to do the offer ourselves, never answer */
			char sdptemp[2048];
			memset(sdptemp, 0, 2048);
			gchar buffer[512];
			memset(buffer, 0, 512);
			gint64 sessid = janus_get_real_time();
			gint64 version = sessid;	/* FIXME This needs to be increased when it changes, so time should be ok */
			g_snprintf(buffer, 512,
				"v=0\r\no=%s %"SCNu64" %"SCNu64" IN IP4 127.0.0.1\r\n",
					"-", sessid, version);
			g_strlcat(sdptemp, buffer, 2048);
			g_strlcat(sdptemp, "s=CM RTP Broadcast\r\nt=0 0\r\n", 2048); /* FIXME @landswellsong: maybe some sane name here? */
			cm_rtpbcast_codecs codecs = src->codecs;

			size_t j;
			for (j = AUDIO; j <= VIDEO; j++) {
				if(codecs.pt[j] >= 0) {
					/* Add audio/video line */
					g_snprintf(buffer, 512,
						"m=%s 1 RTP/SAVPF %d\r\n"
						"c=IN IP4 1.1.1.1\r\n",
						av_names[j],
						codecs.pt[j]);
					g_strlcat(sdptemp, buffer, 2048);
					if(codecs.rtpmap[j]) {
						g_snprintf(buffer, 512,
							"a=rtpmap:%d %s\r\n",
							codecs.pt[j], codecs.rtpmap[j]);
						g_strlcat(sdptemp, buffer, 2048);
					}
					if(codecs.fmtp[j]) {
						g_snprintf(buffer, 512,
							"a=fmtp:%d %s\r\n",
							codecs.pt[j], codecs.fmtp[j]);
						g_strlcat(sdptemp, buffer, 2048);
					}
					if (j == VIDEO) {
						g_snprintf(buffer, 512,
							"a=rtcp-fb:%d nack\r\n",
							codecs.pt[j]);
						g_strlcat(sdptemp, buffer, 2048);
						g_snprintf(buffer, 512,
							"a=rtcp-fb:%d goog-remb\r\n",
							codecs.pt[j]);
						g_strlcat(sdptemp, buffer, 2048);
					}
					g_strlcat(sdptemp, "a=sendonly\r\n", 2048);
				}
			}

			sdp = g_strdup(sdptemp);
			JANUS_LOG(LOG_VERB, "Going to offer this SDP:\n%s\n", sdp);
			result = json_object();
			json_t *currentsrc = cm_rtpbcast_source_to_json(src, session);
			json_object_set_new(result, "stream", currentsrc);
			json_object_set_new(result, "status", json_string("preparing"));
		} else if(!strcasecmp(request_text, "watch-udp")) {
			json_t *id = json_object_get(root, "id");
			if(!id) {
				JANUS_LOG(LOG_ERR, "Missing element (id)\n");
				error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (id)");
				goto error;
			}
			if(!json_is_string(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
				goto error;
			}
			const char *id_value = json_string_value(id);
			janus_mutex_lock(&mountpoints_mutex);
			cm_rtpbcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
			if(mp == NULL) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
				goto error;
			}
			/* Streams is an array now, containing pairs of audio+video streams */
			json_t *streams = json_object_get(root, "streams");
			size_t nstreams = json_array_size(streams);
			if (nstreams==0 || !json_is_array(streams)) {
				JANUS_LOG(LOG_ERR, "Invalid element (streams should be a non-empty array)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (streams should be a non-empty array)");
				goto error;
			}

			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "Request to watch-source-udp of mountpoint %s\n", id_value);

			size_t i;
			json_t *v;
			int port[AV];
			char *hostname[AV];

			/* Remove all previous relays if any */
			cm_rtpbcast_stop_udp_relays(session, NULL);

			/* Create new array */
			session->relay_udp_gateways = g_array_sized_new(FALSE, FALSE, sizeof(cm_rtpbcast_udp_relay_gateway), nstreams);
			/* @landswellsong: might be useful if we switch to pointers again
			g_array_set_clear_func(session->relay_udp_gateways, g_free); */

#ifdef json_array_foreach
			json_array_foreach(streams, i, v) {
#else
			for (i = 0; i < json_array_size(streams); i++) {
				v = json_array_get(streams, i);
#endif
				if (v && !json_is_object(v)) {
					JANUS_LOG(LOG_ERR, "Invalid element (streams elements should be objects)\n");
					error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid value (streams elements should be objects)");
					goto error;
				}

				/* Audio/Video stream params */
				size_t j;
				for (j = AUDIO; j <= VIDEO; j++) {
					char tmpnm[512];
					g_snprintf(tmpnm, 512, "%shost", av_names[j]);
					json_t *mcast = json_object_get(v, tmpnm);
					if(mcast && !json_is_string(mcast)) {
						JANUS_LOG(LOG_ERR, "Invalid element (%s should be a string)\n", tmpnm);
						error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
						g_snprintf(error_cause, 512, "Invalid element (%s should be a string)", tmpnm);
						goto error;
					}
					hostname[j] = (char *)json_string_value(mcast);

					g_snprintf(tmpnm, 512, "%sport", av_names[j]);
					json_t *pt = json_object_get(v, tmpnm);
					if(!pt) {
						JANUS_LOG(LOG_ERR, "Missing element (%s)\n", tmpnm);
						error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
						g_snprintf(error_cause, 512, "Missing element (%s)", tmpnm);
						goto error;
					}
					if(!json_is_integer(pt) || json_integer_value(pt) < 0) {
						JANUS_LOG(LOG_ERR, "Invalid element (%s should be a positive integer)\n", tmpnm);
						error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
						g_snprintf(error_cause, 512, "Invalid element (%s should be a positive integer)", tmpnm);
						goto error;
					}
					port[j] = json_integer_value(pt);
				}

				cm_rtpbcast_rtp_source *src = g_array_index(mp->sources, cm_rtpbcast_rtp_source *, i);

				/* Let's create UDP gateway for Audio and Video */
				cm_rtpbcast_udp_relay_gateway udp_gateway;
				for (j = AUDIO; j <= VIDEO; j++) {
					if (!cm_rtpbcast_construct_address(hostname[j], port[j], &udp_gateway.sin[j])) {
						JANUS_LOG(LOG_ERR, "Can not resolve %s:%d for streaming %s, skipping output.", hostname[j], port[j], av_names[j]);
						udp_gateway.valid[j] = FALSE;
					}
					else {
						udp_gateway.valid[j] = TRUE;
					}
				}
				udp_gateway.source = src;

				/* If we don't need queues, then create a fd */
				if (!cm_rtpbcast_settings.udp_relay_queue_enabled) {
					if ((udp_gateway.fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1) {
						JANUS_LOG(LOG_ERR, "UDP:Relay: cannot create socket! Reason: %s\n", strerror(errno));
						udp_gateway.valid[j] = FALSE; // TODO proper error reporting
					}
				}
				else
					udp_gateway.fd = -1;

				g_array_append_val(session->relay_udp_gateways, udp_gateway);

				/* All preparations are done, add the session to watchers */
				janus_mutex_lock(&src->mutex);
				src->listeners = g_list_append(src->listeners, session);
				janus_mutex_unlock(&src->mutex);
			}

			/* Let's configure session with UDP relay type */
			session->started = TRUE;
			session->stopping = FALSE;

			result = json_object();
			json_object_set_new(result, "status", json_string("preparing"));
		} else if(!strcasecmp(request_text, "start")) {
			if(session->source == NULL) {
				JANUS_LOG(LOG_VERB, "Can't start: no mountpoint set\n");
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't start: no mountpoint set");
				goto error;
			}
			JANUS_LOG(LOG_VERB, "Starting the streaming\n");
			session->paused = FALSE;
			result = json_object();
			/* We wait for the setup_media event to start: on the other hand, it may have already arrived */
			json_object_set_new(result, "status", json_string(session->started ? "started" : "starting"));
		} else if(!strcasecmp(request_text, "pause")) {
			if(session->source == NULL) {
				JANUS_LOG(LOG_VERB, "Can't pause: no mountpoint set\n");
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't start: no mountpoint set");
				goto error;
			}
			JANUS_LOG(LOG_VERB, "Pausing the streaming\n");
			session->paused = TRUE;
			result = json_object();
			json_object_set_new(result, "status", json_string("pausing"));
		} else if(!strcasecmp(request_text, "switch-source")) {
			/* This listener wants to switch to a different source of current mountpoint */
			cm_rtpbcast_mountpoint *mp = session->source->mp;
			if(mp == NULL) {
				JANUS_LOG(LOG_INFO, "Can't switch: not on a mountpoint\n");
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't switch: not on a mountpoint");
				goto error;
			}
			json_t *index = json_object_get(root, "index");
			if(!index) {
				JANUS_LOG(LOG_INFO, "Missing element (index)\n");
				error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (index)");
				goto error;
			}
			if(!json_is_integer(index)) {
				JANUS_LOG(LOG_INFO, "Invalid element (index should be a integer)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (index should be a integer)");
				goto error;
			}
			guint index_value = json_integer_value(index);
			if((mp->sources->len - index_value) < 0) {
				JANUS_LOG(LOG_INFO, "No such source id in current mountpoint/stream\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "No such source in current mountpoint/stream");
				goto error;
			}

			result = json_object();

			if(index_value) {
				cm_rtpbcast_rtp_source *newsrc = g_array_index(mp->sources, cm_rtpbcast_rtp_source *, (index_value-1));
				cm_rtpbcast_schedule_switch(session, newsrc);
				session->autoswitch = FALSE;
			} else {
				session->autoswitch = cm_rtpbcast_settings.autoswitch;
			}
			/* Done */
			json_t *streams = cm_rtpbcast_sources_to_json(session->source->mp->sources, session);
			json_object_set_new(result, "streams", streams);
		} else if(!strcasecmp(request_text, "switch")) {
			/* This listener wants to switch to a different mountpoint
			 * NOTE: this only works for live RTP streams as of now: you
			 * cannot, for instance, switch from a live RTP mountpoint to
			 * an on demand one or viceversa (TBD.) */
			cm_rtpbcast_mountpoint *oldmp = session->source->mp;
			if(oldmp == NULL) {
				JANUS_LOG(LOG_VERB, "Can't switch: not on a mountpoint\n");
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "Can't switch: not on a mountpoint");
				goto error;
			}
			json_t *id = json_object_get(root, "id");
			if(!id) {
				JANUS_LOG(LOG_ERR, "Missing element (id)\n");
				error_code = CM_RTPBCAST_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (id)");
				goto error;
			}
			if(!json_is_string(id)) {
				JANUS_LOG(LOG_ERR, "Invalid element (id should be a string)\n");
				error_code = CM_RTPBCAST_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (id should be a string)");
				goto error;
			}
			const char *id_value = json_string_value(id);
			janus_mutex_lock(&mountpoints_mutex);
			cm_rtpbcast_mountpoint *mp = g_hash_table_lookup(mountpoints, id_value);
			if(mp == NULL) {
				janus_mutex_unlock(&mountpoints_mutex);
				JANUS_LOG(LOG_VERB, "No such mountpoint/stream %s\n", id_value);
				error_code = CM_RTPBCAST_ERROR_NO_SUCH_MOUNTPOINT;
				g_snprintf(error_cause, 512, "No such mountpoint/stream %s", id_value);
				goto error;
			}
			janus_mutex_unlock(&mountpoints_mutex);
			JANUS_LOG(LOG_VERB, "Request to switch to mountpoint/stream %s (old: %s)\n", id_value, oldmp->id);

			cm_rtpbcast_rtp_source *newsrc = cm_rtpbcast_pick_source(mp->sources, session->remb);
			cm_rtpbcast_schedule_switch(session, newsrc);

			/* Done */
			result = json_object();
			json_t *nextsrc = cm_rtpbcast_source_to_json(newsrc, session);
			json_t *currentsrc = cm_rtpbcast_source_to_json(session->source, session);
			json_object_set_new(result, "next", nextsrc);
			json_object_set_new(result, "current", currentsrc);
		} else if(!strcasecmp(request_text, "stop")) {
			if(session->stopping || !session->started) {
				/* Been there, done that: ignore */
				cm_rtpbcast_message_free(msg);
				continue;
			}
			JANUS_LOG(LOG_VERB, "Stopping the streaming\n");
			session->stopping = TRUE;
			session->started = FALSE;
			session->paused = FALSE;
			result = json_object();
			json_object_set_new(result, "status", json_string("stopping"));
			if(session->source) {
				janus_mutex_lock(&session->source->mutex);
				JANUS_LOG(LOG_VERB, "  -- Removing the session from the mountpoint listeners\n");
				if(g_list_find(session->source->listeners, session) != NULL) {
					JANUS_LOG(LOG_VERB, "  -- -- Found!\n");
				}
				session->source->listeners = g_list_remove_all(session->source->listeners, session);
				janus_mutex_unlock(&session->source->mutex);
			}
			session->source = NULL;
			/* Tell the core to tear down the PeerConnection, hangup_media will do the rest */
			gateway->close_pc(session->handle);
		} else {
			JANUS_LOG(LOG_VERB, "Unknown request '%s'\n", request_text);
			error_code = CM_RTPBCAST_ERROR_INVALID_REQUEST;
			g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
			goto error;
		}

		/* Any SDP to handle? */
		if(msg->sdp) {
			JANUS_LOG(LOG_VERB, "This is involving a negotiation (%s) as well (but we really don't care):\n%s\n", msg->sdp_type, msg->sdp);
		}

		/* Prepare JSON event */
		json_t *event = json_object();
		json_object_set_new(event, "streaming", json_string("event"));
		if(result != NULL)
			json_object_set_new(event, "result", result);
		char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		json_decref(event);
		JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
		int ret = gateway->push_event(msg->handle, &cm_rtpbcast_plugin, msg->transaction, event_text, sdp_type, sdp);
		JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
		g_free(event_text);
		if(sdp)
			g_free(sdp);
		cm_rtpbcast_message_free(msg);
		continue;

error:
		{
			/* Prepare JSON error event */
			json_t *event = json_object();
			json_object_set_new(event, "streaming", json_string("event"));
			json_object_set_new(event, "error_code", json_integer(error_code));
			json_object_set_new(event, "error", json_string(error_cause));
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
			int ret = gateway->push_event(msg->handle, &cm_rtpbcast_plugin, msg->transaction, event_text, NULL, NULL);
			JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
			g_free(event_text);
			cm_rtpbcast_message_free(msg);
		}
	}
	g_free(error_cause);
	JANUS_LOG(LOG_VERB, "Leaving CM RTP Broadcast handler thread\n");
	return NULL;
}

/* Helpers to create a listener filedescriptor */
static int cm_rtpbcast_create_fd(int port, in_addr_t mcast, const char* listenername, const char* medianame, const char* mountpointname) {
	struct sockaddr_in address;
	int fd = socket(AF_INET, SOCK_DGRAM, 0);
	if(fd < 0) {
		JANUS_LOG(LOG_ERR, "[%s] Cannot create socket for %s...\n", mountpointname, medianame);
		return -1;
	}
	if(port > 0) {
		int yes = 1;	/* For setsockopt() SO_REUSEADDR */
		setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));

		if(IN_MULTICAST(ntohl(mcast))) {
#ifdef IP_MULTICAST_ALL
			int mc_all = 0;
			if((setsockopt(fd, IPPROTO_IP, IP_MULTICAST_ALL, (void*) &mc_all, sizeof(mc_all))) < 0) {
				JANUS_LOG(LOG_ERR, "[%s] %s listener setsockopt IP_MULTICAST_ALL failed\n", mountpointname, listenername);
				close(fd);
				return -1;
			}
#endif
			struct ip_mreq mreq;
			memset(&mreq, 0, sizeof(mreq));
			mreq.imr_multiaddr.s_addr = mcast;
			if(setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(struct ip_mreq)) == -1) {
				JANUS_LOG(LOG_ERR, "[%s] %s listener IP_ADD_MEMBERSHIP failed\n", mountpointname, listenername);
				close(fd);
				return -1;
			}
			JANUS_LOG(LOG_ERR, "[%s] %s listener IP_ADD_MEMBERSHIP ok\n", mountpointname, listenername);
		}
	}

	address.sin_family = AF_INET;
	address.sin_port = htons(port);
	address.sin_addr.s_addr = INADDR_ANY;
	if(bind(fd, (struct sockaddr *)(&address), sizeof(struct sockaddr)) < 0) {
		JANUS_LOG(LOG_ERR, "[%s] Bind failed for %s (port %d)...\n", mountpointname, medianame, port);
		close(fd);
		return -1;
	}
	return fd;
}

/* Helpers to destroy a streaming mountpoint. */
static void cm_rtpbcast_rtp_source_free(gpointer src) {
	cm_rtpbcast_rtp_source *source = *((cm_rtpbcast_rtp_source **)src);

	size_t j;
	for (j = AUDIO; j <= VIDEO; j++) {
		if(source->fd[j] > 0) {
			close(source->fd[j]);
		}
		g_free(source->codecs.rtpmap[j]);
		g_free(source->codecs.fmtp[j]);

		/* Remove ports from used ports */
		cm_rtpbcast_port_manager_free(source->port[j]);
	}

	janus_mutex_lock(&source->mutex);
	g_list_free(source->listeners);
	g_list_free(source->waiters);
	janus_mutex_unlock(&source->mutex);

	g_free(source);
}

static void cm_rtpbcast_mountpoint_free(cm_rtpbcast_mountpoint *mp) {
	mp->destroyed = janus_get_monotonic_time();

	g_free(mp->id);
	g_free(mp->uid);
	g_free(mp->name);
	g_free(mp->description);

	if (mp->sources) /* TODO: @landswellsong: see if this correctly deallocates everything */
		g_array_free(mp->sources, TRUE);

	g_free(mp);
}

/* Helper to create an RTP live source (e.g., from gstreamer/ffmpeg/vlc/etc.) */
cm_rtpbcast_mountpoint *cm_rtpbcast_create_rtp_source(
		char *id, char *name, char *desc, gboolean recorded,
		const char* allowed_ip, GArray *requests) {
	if(name == NULL) {
		JANUS_LOG(LOG_VERB, "Missing name, will generate a random one...\n");
	}
	cm_rtpbcast_mountpoint *live_rtp = g_malloc0(sizeof(cm_rtpbcast_mountpoint));
	if(live_rtp == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		return NULL;
	}
	live_rtp->id = g_strdup(id);

	/* Generating an MD5 for UID */
	guint64 ml = janus_get_monotonic_time();
	guint32 r = g_random_int();

	char buf[512];
	g_snprintf(buf, 512, "%lu%llu%s", (long unsigned)r, (long long unsigned)ml, CM_RTPBCAST_PACKAGE);
	gchar *md5 = g_compute_checksum_for_string(G_CHECKSUM_MD5, buf, -1);

	live_rtp->uid = g_strdup(md5);

	char tempname[255];
	if(!name) {
		memset(tempname, 0, 255);
		g_snprintf(tempname, 255, "%s", live_rtp->id);
	}
	live_rtp->name = g_strdup(name ? name : tempname);
	live_rtp->description = g_strdup(desc != NULL ? desc : (name ? name : tempname));
	live_rtp->enabled = TRUE;
	live_rtp->recorded = recorded;
	live_rtp->last_thumbnail = janus_get_monotonic_time();

	live_rtp->rc[AUDIO] = NULL;
	live_rtp->rc[VIDEO] = NULL;
	live_rtp->trc[0] = NULL;

	/* Setting allowed IP's */
	live_rtp->whitelisted = FALSE;
	if (allowed_ip) {
		struct hostent *he = gethostbyname2(allowed_ip, AF_INET);
		if (he) {
			memcpy(&live_rtp->allowed_ip.s_addr, he->h_addr, sizeof(he->h_length));
			live_rtp->whitelisted = TRUE;
		}
	}

	/* Iterating over requests array to add all streams */
	live_rtp->sources = g_array_sized_new(FALSE, FALSE, sizeof(cm_rtpbcast_rtp_source*), requests->len);
	g_array_set_clear_func(live_rtp->sources, (GDestroyNotify) cm_rtpbcast_rtp_source_free);
	guint i,j;
	for (i = 0; i < requests->len; i++) {
		cm_rtpbcast_rtp_source_request req = g_array_index(requests, cm_rtpbcast_rtp_source_request, i);
		cm_rtpbcast_rtp_source *live_rtp_source = g_malloc0(sizeof(cm_rtpbcast_rtp_source));

		if(live_rtp_source == NULL) {
			JANUS_LOG(LOG_FATAL, "Memory error!\n");
			goto error;
		}

		live_rtp_source->mp = live_rtp;
		live_rtp_source->index = i+1;
		live_rtp_source->frame_width = 0;
		live_rtp_source->frame_height = 0;
		live_rtp_source->frame_x_scale = 0;
		live_rtp_source->frame_y_scale = 0;
		live_rtp_source->frame_mbw = 0;
		live_rtp_source->frame_mbh = 0;

		live_rtp_source->frame_count = 0;
		live_rtp_source->frame_last_count = 0;
		live_rtp_source->frame_last_usec = 0;

		live_rtp_source->frame_rate = 0;

		live_rtp_source->frame_key_last = 0;
		live_rtp_source->frame_key_distance = 0;
		live_rtp_source->frame_key_overdue = FALSE;

		live_rtp_source->listeners = NULL;
		live_rtp_source->waiters = NULL;
		janus_mutex_init(&live_rtp_source->mutex);

		for (j = AUDIO; j <= VIDEO; j++) {
			janus_mutex_init(&live_rtp_source->stats[j].stat_mutex);
			memset(&live_rtp_source->stats[j], 0, sizeof(live_rtp_source->stats[j]));

			live_rtp_source->mcast[j] = req.mcast[j] ? inet_addr(req.mcast[j]) : INADDR_ANY;
			live_rtp_source->fd[j] = -1;
			live_rtp_source->codecs.pt[j] = req.codec[j];
			live_rtp_source->codecs.rtpmap[j] = req.rtpmap[j] ? g_strdup(req.rtpmap[j]) : NULL;
			live_rtp_source->codecs.fmtp[j] = req.fmtp[j] ? g_strdup(req.fmtp[j]) : NULL;

			/* Checking the next valid port */
			/* TODO @landswellsong: hash table only remembers the source, do we need it
							to remember whether it was video or audio too? */
			live_rtp_source->port[j] = cm_rtpbcast_port_manager_assign(live_rtp_source);
		}
		g_array_append_val(live_rtp->sources, live_rtp_source);
	}

	live_rtp->destroyed = 0;

	/* If we need recording, start it before creating threads */
	if (recorded) {
		cm_rtpbcast_start_recording(live_rtp, 0); /* Source at index 0 will be recorded */
	}

	for (i = 0; i < live_rtp->sources->len; i++) {
		char tempname[256];
		memset(tempname, 0, 255);
		g_snprintf(tempname, 255, "%s %d", live_rtp->id, i);

		GError *error = NULL;
		cm_rtpbcast_rtp_relay_thread_data *dt = g_malloc0(sizeof(cm_rtpbcast_rtp_relay_thread_data)); /* Memory fred within */
		dt->mp = live_rtp;
		dt->i = i;
		g_thread_try_new(tempname, &cm_rtpbcast_relay_thread, dt, &error);
		if(error != NULL) {
			JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the RTP thread...\n", error->code, error->message ? error->message : "??");
			goto error;
		}
	}
	janus_mutex_lock(&mountpoints_mutex);
	g_hash_table_insert(mountpoints, g_strdup(live_rtp->id), live_rtp);
	janus_mutex_unlock(&mountpoints_mutex);
	return live_rtp;

	error:
	g_free(live_rtp->id);
	g_free(live_rtp->uid);
	g_free(live_rtp->name);
	g_free(live_rtp->description);
	g_array_free(live_rtp->sources, TRUE);
	return NULL;
}

/* FIXME Test thread to relay RTP frames coming from gstreamer/ffmpeg/others */
static void *cm_rtpbcast_relay_thread(void *data) {
	JANUS_LOG(LOG_VERB, "Starting streaming relay thread\n");
	cm_rtpbcast_rtp_relay_thread_data *tdata = (cm_rtpbcast_rtp_relay_thread_data *)data;
	cm_rtpbcast_mountpoint *mountpoint = tdata->mp;
	guint nstream = tdata->i;
	cm_rtpbcast_rtp_source *source = g_array_index(mountpoint->sources, cm_rtpbcast_rtp_source*, nstream);
	/* Data no longer needed */
	g_free(data);

	if(!mountpoint) {
		JANUS_LOG(LOG_ERR, "Invalid mountpoint!\n");
		g_thread_unref(g_thread_self());
		return NULL;
	}
	if(source == NULL) {
		JANUS_LOG(LOG_ERR, "[%s] Invalid RTP source mountpoint!\n", mountpoint->name);
		g_thread_unref(g_thread_self());
		return NULL;
	}

	size_t j;
	for (j = AUDIO; j <= VIDEO; j++) {
		static const char *lnames[] = { "Audio", "Video" };
		/* Socket stuff */
		if((source->fd[j] < 0) && (source->port[j] >= 0)) {
			source->fd[j] = cm_rtpbcast_create_fd(source->port[j], source->mcast[j], lnames[j], av_names[j], mountpoint->name);
			if(source->fd[j] < 0) {
				g_thread_unref(g_thread_self());
				return NULL;
			}
			JANUS_LOG(LOG_VERB, "[%s] %s listener bound to port %d\n", lnames[j], mountpoint->name, source->port[j]);
		}
	}

	char *name = g_strdup(mountpoint->name ? mountpoint->name : "??");
	/* Needed to fix seq and ts */
	cm_rtpbcast_context ctx;
	memset(&ctx, 0, sizeof(ctx));

	/* Loop */
	socklen_t addrlen;
	struct sockaddr_in remote;
	int resfd = 0, bytes = 0;
	struct pollfd fds[2];
	char buffer[1500];
	memset(buffer, 0, 1500);
	cm_rtpbcast_rtp_relay_packet packet;
	gboolean is_video_keyframe;

	packet.source_index = nstream;
	cm_rtpbcast_stats_restart(&source->stats[0]);
	cm_rtpbcast_stats_restart(&source->stats[1]);

	while(!g_atomic_int_get(&stopping) && !mountpoint->destroyed) {
		/* Wait for some data */
		for (j = AUDIO; j <= VIDEO; j++) {
			fds[j].fd = 0;
			fds[j].events = 0;
			fds[j].revents = 0;
			if(source->fd[j] > 0) {
				fds[j].fd = source->fd[j];
				fds[j].events = POLLIN;
			}
		}

		resfd = poll(fds, 2, 1000);
		if(resfd < 0) {
			JANUS_LOG(LOG_ERR, "[%s] Error polling... %d (%s)\n", mountpoint->name, errno, strerror(errno));
			break;
		} else if(resfd == 0) {
			cm_rtpbcast_stats_update(&source->stats[0], 0, 0, -1);
			cm_rtpbcast_stats_update(&source->stats[1], 0, 0, -1);
			/* No data, keep going */
			continue;
		}

		for (j = AUDIO; j <= VIDEO; j++) {
			if(source->fd[j] && (fds[j].revents & POLLIN)) {
				/* Got something (RTP) */
				fds[j].revents = 0;
				if(source->active == FALSE) {
					source->active = TRUE;
					/* After inactivity we reset stats */
					cm_rtpbcast_stats_restart(&source->stats[j]);
				}
				addrlen = sizeof(remote);
				bytes = recvfrom(source->fd[j], buffer, 1500, 0, (struct sockaddr*)&remote, &addrlen);

				/* Bad connection simulation */
				if (cm_rtpbcast_settings.simulate_bad_connection) {
					/* Throw a dice if the packet should be just ignored */
					if (cm_rtpbcast_settings.packet_loss_rate > g_random_int_range(0,100)) {
						JANUS_LOG(LOG_VERB, "[%s] Discarding packet for bad connection simulation.\n", mountpoint->name);
						continue;
					}

					/* Retransmit the packet to ourselves with a delay */
					/* TODO */
				}

				/* Note we only update stats for legitimate packets */
				if(source->mp && source->mp->whitelisted &&
					memcmp(&remote.sin_addr.s_addr, &source->mp->allowed_ip.s_addr, sizeof(in_addr_t)) != 0) {
					char buf1[512], buf2[512]; /* inet_ntoa operates on static buffers so we can't call two in same LOG() */
					strncpy(buf1, inet_ntoa(remote.sin_addr), 512);
					strncpy(buf2, inet_ntoa(source->mp->allowed_ip), 512);
					JANUS_LOG(LOG_WARN, "[%s] Got packet from %s whereas only %s is whitelisted\n",
						source->mp->id, buf1, buf2);
					continue;
				}

				//~ JANUS_LOG(LOG_VERB, "************************\nGot %d bytes on the %і channel...\n", av_names[j], bytes);
				/* If paused, ignore this packet */
				if(!mountpoint->enabled)
					continue;
				rtp_header *rtp = (rtp_header *)buffer;
				//~ JANUS_LOG(LOG_VERB, " ... parsed RTP packet (ssrc=%u, pt=%u, seq=%u, ts=%u)...\n",
					//~ ntohl(rtp->ssrc), rtp->type, ntohs(rtp->seq_number), ntohl(rtp->timestamp));
				/* Relay on all sessions */
				packet.data = rtp;
				packet.length = bytes;
				packet.is_video = (j == VIDEO);
				/* Do we have a new stream? */
				if(ntohl(packet.data->ssrc) != ctx.last_ssrc[j]) {
					ctx.last_ssrc[j] = ntohl(packet.data->ssrc);
					JANUS_LOG(LOG_INFO, "[%s] New %s stream! (ssrc=%u)\n", name, av_names[j], ctx.last_ssrc[j]);
					ctx.base_ts_prev[j] = ctx.last_ts[j];
					ctx.base_ts[j] = ntohl(packet.data->timestamp);
					ctx.base_seq_prev[j] = ctx.last_seq[j];
					ctx.base_seq[j] = ntohs(packet.data->seq_number);
					/* FIXME @landswellsong maybe update stats here too? */
				}
				/* FIXME We're assuming Opus here for audio and 15fps for video... */
				ctx.last_ts[j] = (ntohl(packet.data->timestamp)-ctx.base_ts[j])+ctx.base_ts_prev[j]+ (j == AUDIO? 960 : 4500);
				packet.data->timestamp = htonl(ctx.last_ts[j]);
				ctx.last_seq[j] = (ntohs(packet.data->seq_number)-ctx.base_seq[j])+ctx.base_seq_prev[j]+1;
				packet.data->seq_number = htons(ctx.last_seq[j]);

				/* Note we only update stats for legitimate packets */
				/* FIXME @landswellsong are we only expecting IPv4 ? */
				cm_rtpbcast_stats_update(&source->stats[j], bytes + sizeof(struct ip) + sizeof(struct udphdr), ntohs(packet.data->seq_number), (int)j);

				//~ JANUS_LOG(LOG_VERB, " ... updated RTP packet (ssrc=%u, pt=%u, seq=%u, ts=%u)...\n",
					//~ ntohl(rtp->ssrc), rtp->type, ntohs(rtp->seq_number), ntohl(rtp->timestamp));
				packet.data->type = source->codecs.pt[j];

				/* Backup the actual timestamp and sequence number set by the restreamer, in case switching is involved */
				packet.timestamp = ntohl(packet.data->timestamp);
				packet.seq_number = ntohs(packet.data->seq_number);

				/* Detect if the packet is the begnning of a key frame
				 * Code is verbose on purpose for readability, compiler will optimise
				 * Refer to https://tools.ietf.org/html/draft-ietf-payload-vp8-17 */
				/* TODO: @landswellsong assuming VP8 codec only */

				is_video_keyframe = FALSE;
				if (j == VIDEO) {
					/* CC count */
					guint8 cc = buffer[0] & 0x0F;

					/* Start of VP8 payload descriptor */
					guint8 vp8_pd = 4 * 3 + cc * 4;

					/* Flags */
					guint8 flags = buffer[vp8_pd];

					/* VP8 header */
					guint8 vp8_hd = vp8_pd + 1;

					/* Check if the frame is the start of partition */
					if (flags & 0x10) { /* 'S' flag */
						/* Count amount of frames */
						guint64 ml = janus_get_monotonic_time();

						/* Calculate frame rate (FPS) in the stream */
						if (ml - source->frame_last_usec >= STAT_SECOND) {
							source->frame_rate = source->frame_count - source->frame_last_count;
							source->frame_last_count = source->frame_count;
							/* Keep timestamp for last FPS update */
							source->frame_last_usec = ml;
						}
						source->frame_count++;

						/* Optional headers */
						if (flags & 0x80) { /* 'X' flag */
							vp8_hd++;
							guint8 xflags = buffer[vp8_pd + 1];

							if (xflags & 0x80) { /* 'I' flag */
								vp8_hd++;
								if (buffer[vp8_pd + 2] & 0x80) /* 'M' flag */
									vp8_hd++;
							}
							if (xflags & 0x40) /* 'L' flag */
								vp8_hd++;
							if (xflags & 0x20 || xflags & 0x10) /* 'T' or 'K' flag */
								vp8_hd++;
						}

						/* If this is a key frame i.e. an inverse 'P' flag of header */
						cm_rtp_header_vp8 *rtp_vp8h = (cm_rtp_header_vp8 *)buffer;

						if (!(buffer[vp8_hd] & 0x01)) {
							/* Check VP8 start code bytes */
							if (rtp_vp8h->magic0 != 0x9d || rtp_vp8h->magic1 != 0x01 || rtp_vp8h->magic2 != 0x2a) {
								JANUS_LOG(LOG_HUGE, "[%s] Malformed header data on source %x\n", name, GPOINTER_TO_UINT(source));
							} else {
								is_video_keyframe = TRUE;
								/* Calculate frame parameters */
								source->frame_width = (int)(rtp_vp8h->width1&0x3f)<<8 | (int)(rtp_vp8h->width0);
								source->frame_height = (int)(rtp_vp8h->height1&0x3f)<<8 | (int)(rtp_vp8h->height0);
								source->frame_x_scale = rtp_vp8h->width1 >> 6;
								source->frame_y_scale = rtp_vp8h->height1 >> 6;
								source->frame_mbw = (source->frame_width + 0x0f) >> 4;
								source->frame_mbh = (source->frame_height + 0x0f) >> 4;
								/* Calculate key frame distance in the stream */
								source->frame_key_distance = source->frame_count - source->frame_key_last;
								source->frame_key_last = source->frame_count;

								JANUS_LOG(LOG_HUGE, "[%s] Key frame on source %d\n", name, source->index);
								cm_rtpbcast_process_switchers(source);

								if (source->frame_key_overdue) {
									JANUS_LOG(LOG_ERR, "[%s] Key frame arriveed %u frames late on source %d\n", name,
										source->frame_key_distance - cm_rtpbcast_settings.keyframe_distance_alert, source->index);
									source->frame_key_overdue = FALSE;
								}
							}
						} else /* This is an inter-frame */ if (!source->frame_key_overdue) {
							/* If keyframe is overdue, complain */
							guint32 kd = source->frame_count - source->frame_key_last;
							if (kd > cm_rtpbcast_settings.keyframe_distance_alert) {
								JANUS_LOG(LOG_ERR, "[%s] Key frame overdue on source %d\n", name, source->index);
								source->frame_key_overdue = TRUE;
							}
						}
					}
				}

				/* Is there a recorder? */
				/* FIXME @landswellsong support arbitrary stream recording */
				/* FIXME @landswellsong probably put mutexes around recorders */
				if(nstream == 0 && mountpoint->rc[j] && mountpoint->rc[j]->r) {
					// @landswellsong: diabling logging here, streams are recorded by default and this will produce a mess
					// JANUS_LOG(LOG_HUGE, "[%s] Saving %s frame (%d bytes)\n", name, av_names[j], bytes);
					janus_recorder_save_frame(mountpoint->rc[j]->r, buffer, bytes);
					/* Note that keyframe arrived to this recorder */
					if(is_video_keyframe)
						mountpoint->rc[j]->had_keyframe = TRUE;
				}

				if (mountpoint->recorded && nstream == 0 && j == VIDEO) {
					/* Is it time to do thumbnailing? */
					guint64 ml = janus_get_monotonic_time();
					if (!mountpoint->trc[0] && (ml > mountpoint->last_thumbnail + cm_rtpbcast_settings.thumbnailing_interval * 1000000)) {
							cm_rtpbcast_start_thumbnailing(mountpoint, 0); /* Source at index 0 will be recorded */
							mountpoint->last_thumbnail = ml;
					}

					if(mountpoint->trc[0]) {
						/* Note that keyframe arrived to this recorder */
						if(is_video_keyframe)
							mountpoint->trc[0]->had_keyframe = TRUE;

						/* After the call it might update */
						if (mountpoint->trc[0]->r && mountpoint->trc[0]->had_keyframe)
							janus_recorder_save_frame(mountpoint->trc[0]->r, buffer, bytes);

						/* Is it time to stop the thumbnailing? */
						if (mountpoint->trc[0]->r && (ml > mountpoint->last_thumbnail + cm_rtpbcast_settings.thumbnailing_duration * 1000000)) {
							/* Packets density since last source/stats average */
							guint32 den = source->stats[j].max_seq_since_last_avg - source->stats[j].last_avg_seq;
							/* If any packet received, let's check if all packets arrived based on sequence number */
							if (den != 0 && source->stats[j].packets_since_last_avg < den) {
								/* Mark the keyframe for current thumbnailing record as corrupted */
								mountpoint->trc[0]->had_keyframe = FALSE;
								/* Force the restart of thumbnailing record */
								mountpoint->last_thumbnail = 0;
							}
							cm_rtpbcast_stop_thumbnailing(mountpoint, 0);
						}
					}
				}

				/* Go! */
				janus_mutex_lock(&source->mutex);
				g_list_foreach(source->listeners, cm_rtpbcast_relay_rtp_packet, &packet);
				janus_mutex_unlock(&source->mutex);
				continue;
			}
		}
	}
	JANUS_LOG(LOG_VERB, "[%s] Leaving streaming relay thread\n", name);
	g_free(name);
	g_thread_unref(g_thread_self());
	return NULL;
}

	gboolean cm_rtpbcast_construct_address(char *hostname, int port, struct sockaddr_in *sin) {
		/* Let's create and verify the hostname */
		struct hostent *host = gethostbyname(hostname);
		if (host == NULL) {
			JANUS_LOG(LOG_ERR, "UDP:Send: cannot get hostname! Reason: %s\n", strerror(errno));
			return FALSE;
		}

		/* Let's initialize server address */
		memset((char *) sin, 0, sizeof(struct sockaddr_in));
		sin->sin_family = AF_INET;
		sin->sin_port = htons(port);
		sin->sin_addr = *((struct in_addr*) host->h_addr);

		return TRUE;
}

int cm_rtpbcast_relay_rtp_packet_via_udp(cm_rtpbcast_session *session, int source_index, int isvideo, char *buf, int buf_len) {
		if(session->relay_udp_gateways != NULL) {
			cm_rtpbcast_udp_relay_gateway gateway = g_array_index(session->relay_udp_gateways, cm_rtpbcast_udp_relay_gateway , source_index);

			if (gateway.valid[isvideo]) {
				if (cm_rtpbcast_settings.udp_relay_queue_enabled)
					cm_rtpbcast_udp_enqueue(buf, buf_len, &gateway.sin[isvideo]);
				else
					if (sendto(gateway.fd, buf, buf_len, 0, (struct sockaddr *)&gateway.sin[isvideo], sizeof(struct sockaddr_in)) == -1)
						JANUS_LOG(LOG_ERR, "UDP:Relay: cannot send message! Reason %s\n", strerror(errno));
				return 1;
			}
			else return 0;
		}
		return 1;
}

static void cm_rtpbcast_relay_rtp_packet(gpointer data, gpointer user_data) {
	cm_rtpbcast_rtp_relay_packet *packet = (cm_rtpbcast_rtp_relay_packet *)user_data;
	if(!packet || !packet->data || packet->length < 1) {
		JANUS_LOG(LOG_ERR, "Invalid packet...\n");
		return;
	}
	cm_rtpbcast_session *session = (cm_rtpbcast_session *)data;
	if(!session || !session->handle) {
		//~ JANUS_LOG(LOG_ERR, "Invalid session...\n");
		return;
	}
	if(!session->started || session->paused) {
		//~ JANUS_LOG(LOG_ERR, "Streaming not started yet for this session...\n");
		return;
	}

	/* Make sure there hasn't been a publisher switch by checking the SSRC */
	size_t j = packet->is_video? VIDEO : AUDIO;
	if(ntohl(packet->data->ssrc) != session->context.last_ssrc[j]) {
		session->context.last_ssrc[j] = ntohl(packet->data->ssrc);
		session->context.base_ts_prev[j] = session->context.last_ts[j];
		session->context.base_ts[j] = packet->timestamp;
		session->context.base_seq_prev[j] = session->context.last_seq[j];
		session->context.base_seq[j] = packet->seq_number;
	}
	/* Compute a coherent timestamp and sequence number */
	/* FIXME When switching, we assume 15fps for video and Opus and so a 960 ts step for audio */
	session->context.last_ts[j] = (packet->timestamp-session->context.base_ts[j])
		+ session->context.base_ts_prev[j]+(packet->is_video? 4500 : 960);
	session->context.last_seq[j] = (packet->seq_number-session->context.base_seq[j])+session->context.base_seq_prev[j]+1;
	/* Update the timestamp and sequence number in the RTP packet, and send it */
	packet->data->timestamp = htonl(session->context.last_ts[j]);
	packet->data->seq_number = htons(session->context.last_seq[j]);

	if (session->source) {
		if(gateway != NULL) {
			gateway->relay_rtp(session->handle, packet->is_video, (char *)packet->data, packet->length);
		}
	}

	if (session->relay_udp_gateways) {
		cm_rtpbcast_relay_rtp_packet_via_udp(session, packet->source_index, packet->is_video, (char *)packet->data, packet->length);
	}

	/* Restore the timestamp and sequence number to what the publisher set them to */
	packet->data->timestamp = htonl(packet->timestamp);
	packet->data->seq_number = htons(packet->seq_number);
	return;
}

void cm_rtpbcast_port_manager_init(guint minport, guint maxport) {
	port_manager.used_ports = g_hash_table_new(NULL, NULL);
	janus_mutex_init(&port_manager.used_ports_mutex);

	/* Generating random sequence of ports */
	GList *straight = NULL;
	guint i;
	for (i = minport; i <= maxport; i++)
		straight = g_list_prepend(straight, GUINT_TO_POINTER(i));
	guint len = port_manager.ports_available = maxport - minport + 1;

	while (len > 0) {
		GList *el = g_list_nth(straight, g_random_int() % (len--));
		port_manager.free_ports = g_list_prepend(port_manager.free_ports, GUINT_TO_POINTER(el->data));
		straight = g_list_delete_link(straight, el);
	}

	/* Shouldn't happen but just in case */
	if (straight)
		g_list_free(straight);
}

guint cm_rtpbcast_port_manager_assign(gpointer src) {
	janus_mutex_lock(&port_manager.used_ports_mutex);

	/* Inserting the new port to hash table and removing from the list */
	guint res = GPOINTER_TO_UINT(port_manager.free_ports->data);
	port_manager.free_ports = g_list_delete_link(port_manager.free_ports, port_manager.free_ports);
	g_hash_table_insert(port_manager.used_ports, GUINT_TO_POINTER(res), src);

	port_manager.ports_available--;

	janus_mutex_unlock(&port_manager.used_ports_mutex);
	return res;
}

void cm_rtpbcast_port_manager_free(guint port) {
	janus_mutex_lock(&port_manager.used_ports_mutex);

	/* Removing the port from the hash table and inserting to the list */
	g_hash_table_remove(port_manager.used_ports, GUINT_TO_POINTER(port));
	port_manager.free_ports = g_list_insert_before(port_manager.free_ports,
	 	g_list_nth(port_manager.free_ports, port_manager.ports_available), GUINT_TO_POINTER(port));

	port_manager.ports_available++;

	janus_mutex_unlock(&port_manager.used_ports_mutex);
}

void cm_rtpbcast_port_manager_destroy() {
	janus_mutex_lock(&port_manager.used_ports_mutex);

	g_hash_table_destroy(port_manager.used_ports);
	g_list_free(port_manager.free_ports);
	port_manager.ports_available = 0;

	janus_mutex_unlock(&port_manager.used_ports_mutex);
}

static void cm_rtpbcast_stats_restart(cm_rtpbcast_stats *st) {
	janus_mutex_lock(&st->stat_mutex);

	memset(st, 0, sizeof(cm_rtpbcast_stats));
	guint64 ml = janus_get_monotonic_time();
	st->start_usec = ml;
	st->last_avg_usec = ml;

	st->cur = -1.0;
	st->packet_loss_rate = -1.0;
	st->packet_loss_count = -1.0;

	janus_mutex_unlock(&st->stat_mutex);
}

static void cm_rtpbcast_stats_update(cm_rtpbcast_stats *st, gsize bytes, guint32 seq, int isvideo) {
	janus_mutex_lock(&st->stat_mutex);

	/* This overflows at 17179869184 GB of traffic just in case :) */
	st->bytes_since_start += bytes;
	st->bytes_since_last_avg += bytes;

	/* -1 means we were not called on a particular stream */
	if (isvideo != -1) {

		/* If last_seq's are zero, set them */
		if (!st->start_seq)
			st->start_seq = seq;
		if (!st->last_avg_seq)
			st->last_avg_seq = seq;

		/* For current packet loss make sure we don't count packets from
		 * the past, i.e. sent before a reference packet was established */
		if (seq > 0) {
			st->packets_since_start++;
			if (seq >= st->last_avg_seq)
				st->packets_since_last_avg++;
		}

		/* Reset max sequence number stored on overflow */
		if (seq == 65535)
			st->max_seq_since_last_avg = st->last_avg_seq = st->packets_since_last_avg = seq = 0;

		/* Make sure to count the biggest seq number we've seen in this
		 * averaging interval to counter reordering */
		if (st->max_seq_since_last_avg < seq)
			st->max_seq_since_last_avg = seq;

		/* Make sure that we reset the max stored sequence number if the
		 * overflows occurs. This is double check mechanism if 65535 is lost. */
		if (st->max_seq_since_last_avg > seq) {
			st->max_seq_since_last_avg = st->packets_since_last_avg = seq;
			st->last_avg_seq = 0;
		}
	}

	guint64 ml = janus_get_monotonic_time();
	guint64 delay;

	/* If we step over delay, calculate current and compare min/max */
	if (ml - st->last_avg_usec >= cm_rtpbcast_settings.mountpoint_info_interval * STAT_SECOND) {
		/* Calculate */
		delay = ml - st->last_avg_usec;
		st->cur = (8.0L*10e5L)*(gdouble)st->bytes_since_last_avg / (delay != 0 ? delay : 1);

		/* Reset timer */
		st->bytes_since_last_avg  = 0;
		st->last_avg_usec = ml;

		/* Estimate packet loss */
		if (isvideo != -1) {
			guint32 den = st->max_seq_since_last_avg - st->last_avg_seq;
			if (den != 0 && st->packets_since_last_avg < den) {
				st->packet_loss_rate = 1.0 - (gdouble)st->packets_since_last_avg / (gdouble) den;
				st->packet_loss_count += (den - st->packets_since_last_avg);
			} else {
				st->packet_loss_rate = 0.0;
			}

			st->packets_since_last_avg = 0;
			st->last_avg_seq = st->max_seq_since_last_avg;
		} else {
			st->packet_loss_rate = -1.0;
		}
	}

	janus_mutex_unlock(&st->stat_mutex);
}

gint cm_rtpbcast_rtp_source_video_bitrate_sort_function (gconstpointer a, gconstpointer b) {
    cm_rtpbcast_rtp_source * source_a = (cm_rtpbcast_rtp_source *) a;
    cm_rtpbcast_rtp_source * source_b = (cm_rtpbcast_rtp_source *) b;

    return (gint)source_b->stats[VIDEO].cur - (gint)source_a->stats[VIDEO].cur;
}

cm_rtpbcast_rtp_source* cm_rtpbcast_pick_source(GArray *sources, guint64 remb) {
	/* If no sources, oh well */
	if (sources->len <= 0)
		return NULL;

	GArray *sources_dup =  g_array_ref(sources);
	cm_rtpbcast_rtp_source *best_src = NULL;
	gboolean is_stream_stats_available = TRUE;
	/* Let's sort streams descending by current bitrate */
	g_array_sort(sources_dup, cm_rtpbcast_rtp_source_video_bitrate_sort_function);

	guint i; cm_rtpbcast_rtp_source *src; guint64 source_bw;
	for (i = 0; i < sources_dup->len; i++) {
		src = g_array_index(sources_dup, cm_rtpbcast_rtp_source *, i);
		janus_mutex_lock(&src->stats[VIDEO].stat_mutex);
		source_bw = (guint64)src->stats[VIDEO].cur;
		janus_mutex_unlock(&src->stats[VIDEO].stat_mutex);

		/* If current bitrate for any stream is not calculated (-1, null), let's reset current lookup state */
		if (source_bw == -1 || source_bw == NULL) {
			is_stream_stats_available = FALSE;
			best_src = NULL;
			break;
		}

		if (best_src == NULL && is_stream_stats_available) {
			/* If auto-switching is enabled */
			if(cm_rtpbcast_settings.autoswitch) {
				/* If current bitrate is available then pick up the stream with bitrate lower than REMB */
				if (source_bw < remb) {
					best_src = src;
				}
			} else { /* If auto-switching is disabled, let's take the first found stream */
				best_src = src;
			}
		}
	}

	/* If current stream bitrate is not available then pick up the first stream from original order */
	if (!is_stream_stats_available) {
		best_src = g_array_index(sources, cm_rtpbcast_rtp_source *, 0);
	}

	/* If current stream bitrate is available but not matched against the REMB (maybe is 0 or lower than the lowest stream bitrate)
	then pick up the last stream (lowest bitrate) from the sorted list */
	if (best_src == NULL) {
		/* Take the highest bitrate stream */
		best_src = g_array_index(sources_dup, cm_rtpbcast_rtp_source *, (sources->len-1));
	}

	g_array_unref(sources_dup);

	return best_src;
}

void cm_rtpbcast_store_event(json_t* response, const char *event_name) {
	if (!response)
		return;

	/* Creating outer layer JSON */
	json_t *envelope = json_object();

	json_object_set_new(envelope, "plugin", json_string(CM_RTPBCAST_PACKAGE));
	json_object_set_new(envelope, "event", json_string(event_name));
	json_object_set(envelope, "data", response);

	/* Generating an MD5 for filename */
	guint64 ml = janus_get_monotonic_time();
	char ml_str [512];
	g_snprintf(ml_str, 512, "%llu", (long long unsigned)ml);

	guint32 r = g_random_int();
	char r_str [512];
	g_snprintf(r_str, 512, "%u", r);

	char buf[512];
	g_snprintf(buf, 512, "%lu%llu%s", (long unsigned)r, (long long unsigned)ml, CM_RTPBCAST_PACKAGE);
	gchar *md5 = g_compute_checksum_for_string(G_CHECKSUM_MD5, buf, -1);

	/* Constructing the filename */
	char *fname = g_strdup(cm_rtpbcast_settings.job_pattern);

	const char *tags[] = {
		"#{time}",
		"#{rand}",
		"#{md5}",
		"#{plugin}"
	};

	const char *values[] = {
		ml_str,
		r_str,
		md5,
		CM_RTPBCAST_PACKAGE
	};

	_foreach (j, tags)
		fname = str_replace(fname, tags[j], values[j]);

	g_free(md5);

	char fullpath[512];
	g_snprintf(fullpath, 512, "%s/%s.json", cm_rtpbcast_settings.job_path, fname);
	g_free(fname);

	if (json_dump_file(envelope, fullpath, JSON_INDENT(4))) {
		JANUS_LOG(LOG_ERR, "Error saving JSON to %s\n", fullpath);
	} else {
		JANUS_LOG(LOG_INFO, "Created `jobfile` for recording %s\n", fullpath);
	}

	json_decref(envelope);
}

/* Generic functions for both recording and thumbnailing */
static void cm_rtpbcast_generic_start_recording(
		cm_rtpbcast_recorder *recorders[],		/* Array or pointer to recorders */
		cm_rtpbcast_rtp_source *src,		/* Source */
		size_t start, size_t end, 			/* Inclusive, which ones to process */
		const char *fname_pattern,			/* Printf pattern for filename */
		const char *id,									/* streamChannelKey */
		const char *uid,								/* unique ID */
		const char *types[],						/* Type labels, per recorder */
		gboolean is_video[]							/* Whether stream is video, per recorder */
	) {
		/* FIXME @landswellsong which mutex we must lock? */
		/* TODO @landswellsong error reporting upward maybe? */
		size_t j; gboolean res = FALSE;
		for (j = start; j <= end; j++)
			res |= (recorders[j] != NULL);
		if (res)
			return;

		/* Event for notification */
		json_t *response = json_object();
		json_object_set_new(response, "id", json_string(id));
		json_object_set_new(response, "uid", json_string(uid));

		/* Assuming streams contain both video and audio */
		guint64 mt = janus_get_monotonic_time();
		for (j = start; j <= end; j++) {
			char *fname = g_strdup(fname_pattern);

			guint64 ml = janus_get_monotonic_time();
			char ml_str [512];
			g_snprintf(ml_str, 512, "%llu", (long long unsigned)ml);

			const char *tags[] = {
				"#{time}",
				"#{id}",
				"#{type}"
			};

			const char *values[] = {
				ml_str,
				id,
				types[j]
			};

			_foreach (k, tags)
				fname = str_replace(fname, tags[k], values[k]);

			cm_rtpbcast_recorder *recorder = g_malloc0(sizeof(cm_rtpbcast_recorder));
			recorder->r = janus_recorder_create(cm_rtpbcast_settings.archive_path, is_video[j], fname);
			recorder->source = src;
			recorder->had_keyframe = FALSE;
			recorders[j] = recorder;

			g_free(fname);

			if(recorders[j] == NULL) {
				JANUS_LOG(LOG_ERR, "Error starting recorder for %s\n", types[j]);
			} else {
				char fname[512];
				g_snprintf(fname, 512, "%s/%s", recorders[j]->r->dir? recorders[j]->r->dir : "",
					recorders[j]->r->filename? recorders[j]->r->filename : "??");
				JANUS_LOG(LOG_INFO, "[%s] Recording %s started\n", id, types[j]);
				json_object_set_new(response, types[j], json_string(fname));
			}
		}

		/* Note that we are recording and notify  */
		res = FALSE;
		for (j = start; j <= end; j++)
			res |= (recorders[j] != NULL);

		json_decref(response);
}

static void cm_rtpbcast_generic_stop_recording(
	cm_rtpbcast_recorder *recorders[],		/* Array or pointer to recorders */
	cm_rtpbcast_rtp_source *src,		/* Source */
	size_t start, size_t end, 			/* Inclusive, which ones to process */
	const char *id,									/* streamChannelKey */
	const char *uid,								/* unique ID */
	const char *types[],						/* Type labels, per recorder */
	const char *event_name					/* JSON event name for notification */
	) {
	size_t j; gboolean res = TRUE;
	for (j = start; j <= end; j++)
		res &= (!recorders[j]);
	if (res)
		return;

	json_t *response = json_object();

	/* Don't allow to create job file if not frame has been stored. Audio source will be ignored too if no keyframe arrived for video stream */
	int recorder_video_index = (start == end)? 0 : VIDEO;
	if(src->frame_count < 1 || src->frame_key_last < 1 || (recorders[recorder_video_index]->had_keyframe == FALSE)) {
		JANUS_LOG(LOG_INFO, "[%s] Mountpoint has not recorded any video frames.\n", id);
		for (j = start; j <= end; j++) {
			if (recorders[j]) {
				char fname[512];
				g_snprintf(fname, 512, "%s/%s", recorders[j]->r->dir? recorders[j]->r->dir : "",
					recorders[j]->r->filename? recorders[j]->r->filename : "??");
				unlink(fname);
				JANUS_LOG(LOG_INFO, "[%s] Removed %s recording %s\n", id, types[j], fname);
				janus_recorder *tmp = recorders[j]->r;
				recorders[j]->r = NULL;
				recorders[j] = NULL;
				janus_recorder_free(tmp);
			}
		}
	} else {

		/* Event for notification */
		json_object_set_new(response, "id", json_string(id));
		json_object_set_new(response, "uid", json_string(uid));
		/* Timestamp of file creation in seconds */
		json_object_set_new(response, "createdAt", json_integer(janus_get_real_time() / (1000 * 1000)));

		for (j = start; j <= end; j++) {
			if (recorders[j]) {
				char fname[512];
				g_snprintf(fname, 512, "%s/%s", recorders[j]->r->dir? recorders[j]->r->dir : "",
					recorders[j]->r->filename? recorders[j]->r->filename : "??");
				janus_recorder_close(recorders[j]->r);
				json_object_set_new(response, types[j], json_string(fname));
				JANUS_LOG(LOG_INFO, "[%s] Closed %s recording %s\n", id, types[j], fname);
				janus_recorder *tmp = recorders[j]->r;
				recorders[j]->r = NULL;
				recorders[j] = NULL;
				janus_recorder_free(tmp);
			}
		}

		res = TRUE;
		for (j = start; j <= end; j++)
			res &= (!recorders[j]);

		if(res)
			cm_rtpbcast_store_event(response, event_name);
	}

	json_decref(response);
}

void cm_rtpbcast_start_recording(cm_rtpbcast_mountpoint *mnt, int source_index) {
	gboolean is_video[] = { FALSE, TRUE };
	cm_rtpbcast_generic_start_recording(
		mnt->rc,
		g_array_index(mnt->sources, cm_rtpbcast_rtp_source *, source_index),
		AUDIO, VIDEO,
		cm_rtpbcast_settings.recording_pattern,
		mnt->id,
		mnt->uid,
		av_names,
		is_video
	);
}

void cm_rtpbcast_stop_recording(cm_rtpbcast_mountpoint *mnt, int source_index) {
	cm_rtpbcast_generic_stop_recording(
		mnt->rc,
		g_array_index(mnt->sources, cm_rtpbcast_rtp_source *, source_index),
		AUDIO, VIDEO,
		mnt->id,
		mnt->uid,
		av_names,
		"archive-finished"
	);
}

void cm_rtpbcast_start_thumbnailing(cm_rtpbcast_mountpoint *mnt, int source_index) {
	gboolean is_video[] = { TRUE };
	const char *types[] = { "thumb"};
	cm_rtpbcast_generic_start_recording(
		mnt->trc,
		g_array_index(mnt->sources, cm_rtpbcast_rtp_source *, source_index),
		0, 0,
		cm_rtpbcast_settings.thumbnailing_pattern,
		mnt->id,
		mnt->uid,
		types,
		is_video
	);
}

void cm_rtpbcast_stop_thumbnailing(cm_rtpbcast_mountpoint *mnt, int source_index) {
	const char *types[] = { "thumb"};
	cm_rtpbcast_generic_stop_recording(
		mnt->trc,
		g_array_index(mnt->sources, cm_rtpbcast_rtp_source *, source_index),
		0, 0,
		mnt->id,
		mnt->uid,
		types,
		"thumbnailing-finished"
	);
}

char *str_replace(char *instr, const char *needle, const char *replace) {
	GRegex* regex = g_regex_new(needle, 0, 0, NULL);
	char* new = g_regex_replace_literal(regex, instr, -1, 0, replace, 0, NULL);
	g_regex_unref (regex);
	g_free(instr);
	return new;
}

void cm_rtpbcast_mountpoint_destroy(gpointer data, gpointer user_data) {
	cm_rtpbcast_mountpoint * mp = (cm_rtpbcast_mountpoint *) data;
	if(!mp->destroyed) {
		/* FIXME Should we kick the current viewers as well? */
		guint i;
		for (i = 0; i < mp->sources->len; i++) {
			cm_rtpbcast_rtp_source *src = g_array_index(mp->sources,
				cm_rtpbcast_rtp_source *, i);

			janus_mutex_lock(&src->mutex);
			GList *viewer = g_list_first(src->listeners);
			/* Prepare JSON event */
			json_t *event = json_object();
			json_object_set_new(event, "streaming", json_string("event"));
			json_t *result = json_object();
			json_object_set_new(result, "status", json_string("stopped"));
			json_object_set_new(event, "result", result);
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			while(viewer) {
				cm_rtpbcast_session *session = (cm_rtpbcast_session *)viewer->data;
				/* TODO: why don't we have a per-session mutex? */
				if(session != NULL) {
					session->stopping = TRUE;
					session->started = FALSE;
					session->paused = FALSE;
					/* If the session was a watcher */
					if (session->source) {
						session->source = NULL;
						/* Tell the core to tear down the PeerConnection, hangup_media will do the rest */
						gateway->push_event(session->handle, &cm_rtpbcast_plugin, NULL, event_text, NULL, NULL);
						gateway->close_pc(session->handle);
					}
					/* If the session was a repeater. Note this removes session from listeners so
					 * g_list_remove_all becomes a redundant call. */
					cm_rtpbcast_stop_udp_relays(session, src); /* TODO: any kind of notification maybe? */
				}
				/* FIXME: why not remove_link ? */
				src->listeners = g_list_remove_all(src->listeners, session);
				viewer = g_list_first(src->listeners);
			}
			g_free(event_text);
			janus_mutex_unlock(&src->mutex);
		}

		/* If it's recording, stop it */
		if(mp->rc[AUDIO] && mp->rc[AUDIO]->r || mp->rc[VIDEO] && mp->rc[VIDEO]->r)
			cm_rtpbcast_stop_recording(mp, 0);

		if(mp->trc[0] && mp->trc[0]->r)
			cm_rtpbcast_stop_thumbnailing(mp, 0);

		/* Remove from respective session */
		if(mp->session) {
			mp->session->mps = g_list_remove_all(mp->session->mps, mp);
			mp->session = NULL;
		}

		/* Remove mountpoint from the hashtable: this will get it destroyed */
		mp->destroyed = janus_get_monotonic_time();
		g_hash_table_remove(mountpoints, mp->id);
		/* Cleaning up and removing the mountpoint is done in a lazy way */
		old_mountpoints = g_list_append(old_mountpoints, mp);
	}
}

void cm_rtpbcast_notify_supers(json_t* response) {
	if(!super_sessions)
		return;

	if(!response)
		return;

	g_list_foreach(super_sessions, cm_rtpbcast_notify_session, response);
}

void cm_rtpbcast_notify_session(gpointer data, gpointer user_data) {
	cm_rtpbcast_session *session = data;
	json_t *event = user_data;

	if (!session || !event)
		return;

	char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
	JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
	int ret = gateway->push_event(session->handle, &cm_rtpbcast_plugin, NULL, event_text, NULL, NULL);
	JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
	g_free(event_text);
}

void cm_rtpbcast_stop_udp_relays(cm_rtpbcast_session *session, cm_rtpbcast_rtp_source *srcmx) {
	/* Check if we have udp relays to begin with */
	if (!session->relay_udp_gateways)
		return;

	/* Remove ourselves from every source */
	int i;
	for (i = 0; i < session->relay_udp_gateways->len; i++) {
		cm_rtpbcast_udp_relay_gateway gw = g_array_index(session->relay_udp_gateways, cm_rtpbcast_udp_relay_gateway, i);

		/* This function can be called from within mountpoint_destroy() which has a mutex locked over one source
		 * so we check the argument here to prevent deadlocking */
		if (srcmx != gw.source)
			janus_mutex_lock(&gw.source->mutex);
		gw.source->listeners = g_list_remove_all(gw.source->listeners, session);
		if (srcmx != gw.source)
			janus_mutex_unlock(&gw.source->mutex);

		/* If we had a fd open close it */
		if (gw.fd >= 0) {
			close(gw.fd);
			gw.fd = -1;
		}
	}

	g_array_free(session->relay_udp_gateways, TRUE);
	session->relay_udp_gateways = NULL;
}


void cm_rtpbcast_schedule_switch(cm_rtpbcast_session *sessid, cm_rtpbcast_rtp_source *newsrc) {
	JANUS_LOG(LOG_VERB, "Scheduling session 0x%x to switch to source 0x%x\n", GPOINTER_TO_UINT(sessid), GPOINTER_TO_UINT(newsrc));
	cm_rtpbcast_rtp_source *ns = sessid->nextsource;
	if (ns == newsrc)
		return; /* Nothing to do */

	janus_mutex_lock(&sessid->mutex);
	/* Clearing old switching source if any */
	if (ns) {
		janus_mutex_lock(&ns->mutex);
		ns->waiters = g_list_remove_all(ns->waiters, sessid);
		sessid->nextsource = NULL;
		janus_mutex_unlock(&ns->mutex);
	}

	/* Attaching to a new source */
	sessid->nextsource = newsrc;
	janus_mutex_lock(&newsrc->mutex);
	newsrc->waiters = g_list_prepend(newsrc->waiters, sessid);
	janus_mutex_unlock(&newsrc->mutex);

	janus_mutex_unlock(&sessid->mutex);
}

void cm_rtpbcast_unschedule_switch(cm_rtpbcast_session *sessid) {
	JANUS_LOG(LOG_VERB, "Unscheduling session 0x%x from switching\n", GPOINTER_TO_UINT(sessid));
	cm_rtpbcast_rtp_source *ns = sessid->nextsource;
	if (ns) {
		janus_mutex_lock(&ns->mutex);
		janus_mutex_lock(&sessid->mutex);

		ns->waiters = g_list_remove_all(ns->waiters, sessid);
		sessid->nextsource = NULL;

		janus_mutex_unlock(&sessid->mutex);
		janus_mutex_unlock(&ns->mutex);
	}
}

static void cm_rtpbcast_execute_switching(gpointer data, gpointer user_data) {
	cm_rtpbcast_session *sessid = (cm_rtpbcast_session *)data;
	cm_rtpbcast_rtp_source *source = (cm_rtpbcast_rtp_source *)user_data;
	cm_rtpbcast_rtp_source *oldsrc = sessid->source;

	janus_mutex_lock(&sessid->mutex);

	/* If somehow the sources are the same, prevent a deadlock */
	if (source != oldsrc)
		janus_mutex_lock(&oldsrc->mutex);

	/* Remove from old source and attach to new source */
	oldsrc->listeners = g_list_remove_all(oldsrc->listeners, sessid);
	source->listeners = g_list_prepend(source->listeners, sessid);
	sessid->source = source;
	JANUS_LOG(LOG_VERB, "Session 0x%x switched to source 0x%x\n", GPOINTER_TO_UINT(sessid), GPOINTER_TO_UINT(source));

	if (source != oldsrc)
		janus_mutex_unlock(&oldsrc->mutex);

	janus_mutex_unlock(&sessid->mutex);

	json_t *event = json_object();
	json_object_set_new(event, "streaming", json_string("event"));
	json_t *result = json_object();

	json_object_set_new(result, "event", json_string("changed"));

	json_t *streams = cm_rtpbcast_sources_to_json(source->mp->sources, sessid);
	json_object_set_new(result, "streams", streams);

	json_object_set_new(event, "result", result);
	char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
	json_decref(event);

	gateway->push_event(sessid->handle, &cm_rtpbcast_plugin, NULL, event_text, NULL, NULL);
}

void cm_rtpbcast_process_switchers(cm_rtpbcast_rtp_source *src) {
	if (src->waiters) {
		janus_mutex_lock(&src->mutex);
		/* Switch everybody */
		g_list_foreach(src->waiters, cm_rtpbcast_execute_switching, src);
		/* Kill everybody */
		g_list_free(src->waiters);
		src->waiters = NULL;
		janus_mutex_unlock(&src->mutex);
	}
}

json_t *cm_rtpbcast_mountpoints_to_json(cm_rtpbcast_session *session) {
	json_t *mps = json_array();
	janus_mutex_unlock(&mountpoints_mutex);
	GHashTableIter iter;
	gpointer value;
	g_hash_table_iter_init(&iter, mountpoints);
	while (g_hash_table_iter_next(&iter, NULL, &value)) {
		cm_rtpbcast_mountpoint *mp = value;
		json_t *v = cm_rtpbcast_mountpoint_to_json(mp, session);
		json_array_append_new(mps, v);
	}
	janus_mutex_unlock(&mountpoints_mutex);
	return mps;
}

json_t *cm_rtpbcast_mountpoint_to_json(cm_rtpbcast_mountpoint *mountpoint, cm_rtpbcast_session *session) {
	json_t *mp = json_object();

	json_object_set_new(mp, "id", json_string(mountpoint->id));
	json_object_set_new(mp, "uid", json_string(mountpoint->uid));
	json_object_set_new(mp, "name", json_string(mountpoint->name));
	json_object_set_new(mp, "description", json_string(mountpoint->description));
	json_object_set_new(mp, "enabled", json_integer(mountpoint->enabled));
	json_object_set_new(mp, "recorded", json_integer(mountpoint->recorded));
	json_object_set_new(mp, "whitelisted", json_integer(mountpoint->whitelisted));

	json_t *st = cm_rtpbcast_sources_to_json(mountpoint->sources, session);
	json_object_set_new(mp, "streams", st);

	return mp;
}

json_t *cm_rtpbcast_sources_to_json(GArray *sources, cm_rtpbcast_session *session) {
	json_t *st = json_array();
	guint i;
	for (i = 0; i < sources->len; i++) {
		cm_rtpbcast_rtp_source *src = g_array_index(sources, cm_rtpbcast_rtp_source*, i);
		json_t *v = cm_rtpbcast_source_to_json(src, session);
		json_array_append_new(st, v);
	}
	return st;
}

json_t *cm_rtpbcast_source_stats_to_json(cm_rtpbcast_rtp_source *src) {
	json_t *s = json_object();
	size_t j;
	for (j = AUDIO; j <= VIDEO; j++) {
		static const char *lnames[] = { "audio", "video" };
		json_t *v = json_object();
		json_t *b = json_object();
		json_t *u = json_object();

		janus_mutex_lock(&src->stats[j].stat_mutex);
		json_object_set_new(v, "bitrate", (src->stats[j].cur == -1) ? json_null() : json_real(src->stats[j].cur));
		json_object_set_new(v, "packet-loss", (src->stats[j].packet_loss_rate == -1) ? json_null() : json_real(src->stats[j].packet_loss_rate));
		json_object_set_new(v, "packet-loss-rate", (src->stats[j].packet_loss_rate == -1) ? json_null() : json_real(src->stats[j].packet_loss_rate));
		json_object_set_new(v, "packet-loss-count", (src->stats[j].packet_loss_count == -1) ? json_null() : json_integer(src->stats[j].packet_loss_count));
		janus_mutex_unlock(&src->stats[j].stat_mutex);

		json_object_set_new(s, lnames[j], v);
	}
	return s;
}

json_t *cm_rtpbcast_source_to_json(cm_rtpbcast_rtp_source *src, cm_rtpbcast_session *session) {
	json_t *v = json_object();

	json_object_set_new(v, "id", json_string(src->mp->id));
	json_object_set_new(v, "uid", json_string(src->mp->uid));
	json_object_set_new(v, "index", json_integer(src->index));

	json_t *rtp = json_object();
	json_t *audio = json_object();
	json_t *video = json_object();
	json_object_set_new(audio, "port", json_integer(src->port[AUDIO]));
	json_object_set_new(audio, "host", json_string(g_strdup(cm_rtpbcast_settings.hostname)));
	json_object_set_new(video, "port", json_integer(src->port[VIDEO]));
	json_object_set_new(video, "host", json_string(g_strdup(cm_rtpbcast_settings.hostname)));
	json_object_set_new(rtp, "audio", audio);
	json_object_set_new(rtp, "video", video);
	json_object_set_new(v, "rtp-endpoint", rtp);

	json_t *rtc = json_object();
	json_object_set_new(rtc, "listeners", json_integer(g_list_length(src->listeners)));
	json_object_set_new(rtc, "waiters", json_integer(g_list_length(src->waiters)));
	json_object_set_new(v, "webrtc-endpoint", rtc);

	json_object_set_new(v, "stats", cm_rtpbcast_source_stats_to_json(src));

	json_t *f = json_object();
	json_object_set_new(f, "width", json_integer(src->frame_width));
	json_object_set_new(f, "height", json_integer(src->frame_height));
	json_object_set_new(f, "fps", json_integer(src->frame_rate));
	json_object_set_new(f, "key-distance", json_integer(src->frame_key_distance));
	json_object_set_new(v, "frame", f);

	json_t *u = json_object();

	json_t *webrtc_status = NULL;
	if (session->source == src) {
		webrtc_status  = json_string("active");
	} else if (session->nextsource == src) {
		webrtc_status  = json_string("next");
	} else {
		webrtc_status  = json_null();
	}

	json_object_set_new(u, "webrtc-status", webrtc_status);
	json_object_set_new(u, "autoswitch-enabled", json_integer(session->autoswitch));
	json_object_set_new(u, "remb", (session->remb == -1)? json_null() : json_integer(session->remb));
	json_object_set_new(v, "session", u);

	return v;
}
